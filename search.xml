<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[搜索术]]></title>
    <url>%2F2018%2F08%2F14%2F%E6%90%9C%E7%B4%A2%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[偶然看到群里有人分享《12 堂超级搜索术》的教程，看完过后，觉得收获并不太大，简单总结下学习收获吧！ 搜索心法​ 找什么：准确描述自己想要的搜索目标 哪里找：准确找到垂直搜索渠道发现更多同类型网站 怎么找：掌握高级搜索指令 信息搜索逻辑​ 搜狗微信、搜狗知乎 大数据导航（大数据垂直网站） 虫部落快搜（搜索集大成者） 转变思路：应用商店搜索相关 APP 搜索技巧​ 关键词搜索 特定时间内的关键信息（关键词 20xx..20xx） 特定网站（site） 关键词 空格 site:限定站点 限定文件类型（filetype） 将关键词限定在标题中（intitle）allinurl 不包含某关键词（减号-） 收藏网站猎手导航（磁链，搜索影视剧） 网盘搜索、微盘搜索 专业资源网站搜索 ​ 图片：pexels、500px ​ ppt 模板：officeplus、比格 ppt ​]]></content>
      <tags>
        <tag>瞎BB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring]]></title>
    <url>%2F2018%2F08%2F03%2FSpring%2F</url>
    <content type="text"><![CDATA[Spring 优点 方便解耦，简化开发：将所有对象创建和依赖关系维护交给 Spring 管理； AOP 编程的支持； 声明式事务的支持； 方便程序的测试：通过注解方便的测试 Spring 程序； 方便集成各种优秀框架，Struts、Hibernate、MyBatis、Quartz 等。 IOC 与 DIIOC 控制反转，是指对象实例化权利由 spring 容器来管理 ； DI 依赖注入，在 spring 创建对象的过程中，对象所依赖的属性通过配置注入对象中。 Spring 在 web 开发中应用 导入 spring-web-4.2.4.RELEASE.jar 包; 在 web.xml 文件中配置 listener：&lt;listener&gt;&lt;listener-class&gt;org.springframework.web.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;，这个 ContextLoaderListener 实现了 ServletContextLister，当服务器启动时，将 ApplicationContext(其实是它的实现类 WebApplicationContext)对象存入到 ServletContext 中; 在 web.xml 文件中配置 applicationContext.xml 文件的位置 ，&lt;context_param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param_name&gt;&lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context_parm&gt;。 Spring 事务管理Spring 事务管理主要提供三个接口来完成： org.springframework.transaction.PlatformTransactionManager ​ DataSourceTransactionManger 主要针对于 JdbcTemplate、MyBatis 开发； ​ HibernateTransactionManasger 主要针对于 Hibernate 开发； ​ JpaTransactionManager 主要针对于 JPA 开发。 TransactionDefinition TransactionStatus 声明式事务管理]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库索引 B+ 树]]></title>
    <url>%2F2018%2F07%2F31%2FB%E6%A0%91%2F</url>
    <content type="text"><![CDATA[红黑树红黑树是一颗二叉搜索树，在每个结点上增加了一个存储位表示结点的颜色（BLACK 或 RED），通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其他路径长出 2 倍，因而是近似平衡的。 每个结点包含 5 个属性：color、key、left、right、key。 红黑性质： 每个结点是红色或黑色的； 根节点是黑色的； 叶节点（NIL）是黑色的； 红色结点的两个子结点都是黑色的； 每个结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。 一颗有 n 个内部结点的红黑树的高度（黑高bh(x)）至多为 2lg(n+1)，红黑树查询、插入、删除操作的时间复杂度均为 O(lgn)。 插入、删除操作对树做了修改，结果可能违反红黑性质，必须修改树中某些结点的颜色及指针结构（通过旋转完成）。左旋转（X 的右孩子是 Y）： Y 的左孩子成为 X 的右孩子； X 成为 Y 的左孩子； B 树B 树的严格高度可能比一颗红黑树的高度小许多，因为分支因子（表示高度的对数的底数可以非常大）。 B+ 树由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。 B 树和 B+ 树的总结 磁盘换 SSD 后，还有 B/B+ 树的用武之地吗？ 在 SSD 相对在服务器端普及的今天，为什么大部分数据库还是用 B/B+ 树实现的？ B+树的设计：把树的上面几层放在内存里，尽量减少外存访问次数；然后把数据按页存储，每次读写单元都是一个页。这两点现在依然很好的贴合SSD的特征。 从机械硬盘到固态硬盘后，b树怎么办？]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密解密技术]]></title>
    <url>%2F2018%2F07%2F24%2F%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[大学时对一些网络协议，加密解密原理颇有兴趣，但那时不会编码，无法实现。本文以代码为主，原理次之，记录于此。 对称加密使用的密钥只有一个，加密解密使用同一密钥。数据发送方将明文与密钥经加密算法处理后发送出去，数据接收方使用密钥及相同算法的逆算法解密密文。常用的对称加密算法： DESDES（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合。DES 使用 56 位密钥，24 小时内即可被破解，但还是可以在某些简单应用中使用 DES 加密算法。注意：DES 密钥的长度必须是 8 的倍数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class DES &#123; // 测试 public static void main(String args[]) &#123; // 待加密内容 String str = "TEST"; // 密码，长度要是8的倍数 String password = "12345678"; byte[] result = DES.encrypt(str.getBytes(), password); System.out.println("加密后：" + new String(result)); //加密后： // 直接将如上内容解密 try &#123; byte[] decryResult = DES.decrypt(result, password); System.out.println("解密后：" + new String(decryResult)); //解密后：TEST &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; // key1(SecretKeyFactory)：3132323434373738 // key2(KeyGenerator)：85ABC12F54AB676E // key3(SecretKeySpec)：3132333435363738 printKey(password.getBytes()); &#125; public static byte[] encrypt(byte[] datasource, String password) &#123; try &#123; //密钥 DESKeySpec desKey = new DESKeySpec(password.getBytes()); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES"); SecretKey securekey = keyFactory.generateSecret(desKey); // Cipher对象实际完成加密操作 Cipher cipher = Cipher.getInstance("DES"); SecureRandom random = new SecureRandom(); cipher.init(Cipher.ENCRYPT_MODE, securekey, random); // 正式执行加密操作 return cipher.doFinal(datasource); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; return null; &#125; public static byte[] decrypt(byte[] src, String password) throws Exception &#123; // 创建一个DESKeySpec对象 DESKeySpec desKey = new DESKeySpec(password.getBytes()); // 创建一个密匙工厂 SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES"); // 将DESKeySpec对象转换成SecretKey对象 SecretKey securekey = keyFactory.generateSecret(desKey); // Cipher对象实际完成解密操作 Cipher cipher = Cipher.getInstance("DES"); // DES算法要求有一个可信任的随机数源 SecureRandom random = new SecureRandom(); // 用密匙初始化Cipher对象 cipher.init(Cipher.DECRYPT_MODE, securekey, random); // 真正开始解密操作 return cipher.doFinal(src); &#125; public static void printKey(byte[] keyBytes)&#123; try&#123; //第一种，Factory DESKeySpec keySpec=new DESKeySpec(keyBytes); SecretKeyFactory keyFactory=SecretKeyFactory.getInstance("DES"); SecretKey key1=keyFactory.generateSecret(keySpec); //第二种, Generator KeyGenerator keyGenerator=KeyGenerator.getInstance("DES"); keyGenerator.init(56, new SecureRandom(keyBytes));//key为8个字节，实际用了56位； 后面随机数用key作为种子seed生成 SecretKey key2=keyGenerator.generateKey(); //第三种， SecretKeySpec SecretKey key3=new SecretKeySpec(keyBytes, "DES");//SecretKeySpec类同时实现了Key和KeySpec接口 //打印 System.out.println("key1(SecretKeyFactory)："+byteToHexString(key1.getEncoded())); System.out.println("key2(KeyGenerator)："+byteToHexString(key2.getEncoded())); System.out.println("key3(SecretKeySpec)："+byteToHexString(key3.getEncoded())); &#125;catch(Exception e)&#123; System.out.println(e.toString()); &#125; &#125; public static String byteToHexString(byte[] bytes) &#123; StringBuffer sb = new StringBuffer(bytes.length); String sTemp; for (int i = 0; i &lt; bytes.length; i++) &#123; sTemp = Integer.toHexString(0xFF &amp; bytes[i]); if (sTemp.length() &lt; 2) sb.append(0); sb.append(sTemp.toUpperCase()); &#125; return sb.toString(); &#125; private static byte toByte(char c) &#123; byte b = (byte) "0123456789ABCDEF".indexOf(c); return b; &#125;&#125; AESAES（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高。AES 使用 128、192 或 256 位密钥，代码如下，与 DES 实现类似： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class AES &#123; public static void main(String[] args) &#123; // 待加密内容 String str = "TEST"; // 密码，长度要是8的倍数 String password = "12345678"; byte[] encryptResult = AES.encrypt(str.getBytes(), password); System.out.println("加密后：" + new String(encryptResult)); // 加密后： byte[] decryptResult = AES.decrypt(encryptResult, password); System.out.println("解密后：" + new String(decryptResult)); // 解密后：TEST // key1(KeyGenerator)：84AAC12F54AB666ECFC2A83C676908C8 // key2(SecretKey)：3132333435363738 printKey(password.getBytes()); &#125; public static byte[] encrypt(byte[] datasource, String password) &#123; KeyGenerator kgen; try &#123; kgen = KeyGenerator.getInstance("AES"); kgen.init(128, new SecureRandom(password.getBytes())); SecretKey secretKey = kgen.generateKey(); byte[] enCodeFormat = secretKey.getEncoded(); // 转换为AES专用密钥 SecretKeySpec key = new SecretKeySpec(enCodeFormat, "AES"); // 创建密码器 Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.ENCRYPT_MODE, key); return cipher.doFinal(datasource); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static byte[] decrypt(byte[] src, String password) &#123; KeyGenerator kgen; try &#123; kgen = KeyGenerator.getInstance("AES"); kgen.init(128, new SecureRandom(password.getBytes())); SecretKey secretKey = kgen.generateKey(); byte[] enCodeFormat = secretKey.getEncoded(); // 转换为AES专用密钥 SecretKeySpec key = new SecretKeySpec(enCodeFormat, "AES"); // 创建密码器 Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.DECRYPT_MODE, key); return cipher.doFinal(src); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static String byteToHexString(byte[] bytes) &#123; StringBuffer sb = new StringBuffer(bytes.length); String sTemp; for (int i = 0; i &lt; bytes.length; i++) &#123; sTemp = Integer.toHexString(0xFF &amp; bytes[i]); if (sTemp.length() &lt; 2) sb.append(0); sb.append(sTemp.toUpperCase()); &#125; return sb.toString(); &#125; public static void printKey(byte[] keyBytes)&#123; try&#123; // KeyGenerator KeyGenerator keyGenerator=KeyGenerator.getInstance("AES"); keyGenerator.init(128, new SecureRandom(keyBytes));//key为128, 192 or 256 SecretKey key2=keyGenerator.generateKey(); // SecretKeySpec SecretKey key3=new SecretKeySpec(keyBytes, "AES");//SecretKeySpec类同时实现了Key和KeySpec接口 //打印 System.out.println("key1(KeyGenerator)："+byteToHexString(key2.getEncoded())); System.out.println("key2(SecretKey)："+byteToHexString(key3.getEncoded())); &#125;catch(Exception e)&#123; System.out.println(e.toString()); &#125; &#125;&#125; PS： ​ Should I use KeyGenerator or SecretKeyFactory? ​ 产生密钥的四个类的区别： KeyGenerator， KeyPairGenerator，KeyFactory，SecretKeyFactory 非对称加密使用一对密钥「公钥、私钥」。主要算法有，RSA、ECC（椭圆曲线加密算法）， 两种用法： 用于加密：公钥加密，私钥解密，这样只有我自己知道别人发送给我的消息； 用于签名：私钥加密，公钥解密，这样只有我自己可以发布这个签名，私钥负责签名，公钥负责验证。 关于这些加密算法的实现其实都大同小异，网上资料也很多，就不再发出来了。 Hash（散列）算法引用百度百科介绍，「就是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射 」。常见的有 MD5 和 SHA 算法。 输出散列值长度（bits） 最大输入消息长度（bits） MD5（消息摘要算法） 128 无限 SHA1 160 2^64 - 1 SHA2(SHA256) 256 2^128 - 1 SHA3(SHA256、SHA512) 256、512 无限 使用 JDK 提供的 MessageDigest 对象获取信息摘要，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139public class Test &#123; protected static char hexDigits[] = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' &#125;; public static MessageDigest messagedigest = null; /** * 对一个文件获取md5值 */ public static String getMD5(File file) throws IOException, NoSuchAlgorithmException &#123; messagedigest = MessageDigest.getInstance("MD5"); FileInputStream in = new FileInputStream(file); FileChannel ch = in.getChannel(); MappedByteBuffer byteBuffer = ch.map(FileChannel.MapMode.READ_ONLY, 0, file.length()); messagedigest.update(byteBuffer); return bufferToHex(messagedigest.digest()); &#125; /*** * 获取文件SHA1码 */ public static String getSha1(File file) throws OutOfMemoryError, IOException, NoSuchAlgorithmException &#123; messagedigest = MessageDigest.getInstance("SHA-1"); FileInputStream in = new FileInputStream(file); FileChannel ch = in.getChannel(); MappedByteBuffer byteBuffer = ch.map(FileChannel.MapMode.READ_ONLY, 0, file.length()); messagedigest.update(byteBuffer); return bufferToHex(messagedigest.digest()); &#125; /** * 获取文件SHA256码 */ public static String getSha256(File file) throws OutOfMemoryError, IOException, NoSuchAlgorithmException &#123; messagedigest = MessageDigest.getInstance("SHA-256"); FileInputStream in = new FileInputStream(file); FileChannel ch = in.getChannel(); MappedByteBuffer byteBuffer = ch.map(FileChannel.MapMode.READ_ONLY, 0, file.length()); messagedigest.update(byteBuffer); return bufferToHex(messagedigest.digest()); &#125; /** * 获取文件SHA512码 */ public static String getSha512(File file) throws OutOfMemoryError, IOException, NoSuchAlgorithmException &#123; messagedigest = MessageDigest.getInstance("SHA-512"); FileInputStream in = new FileInputStream(file); FileChannel ch = in.getChannel(); MappedByteBuffer byteBuffer = ch.map(FileChannel.MapMode.READ_ONLY, 0, file.length()); messagedigest.update(byteBuffer); return bufferToHex(messagedigest.digest()); &#125; public static String getMD5String(String s) &#123; return getMD5String(s.getBytes()); &#125; public static String getMD5String(byte[] bytes) &#123; messagedigest.update(bytes); return bufferToHex(messagedigest.digest()); &#125; /** * @Description 计算二进制数据 * @return String */ private static String bufferToHex(byte bytes[]) &#123; return bufferToHex(bytes, 0, bytes.length); &#125; private static String bufferToHex(byte bytes[], int m, int n) &#123; StringBuffer stringbuffer = new StringBuffer(2 * n); int k = m + n; for (int l = m; l &lt; k; l++) &#123; appendHexPair(bytes[l], stringbuffer); &#125; return stringbuffer.toString(); &#125; private static void appendHexPair(byte bt, StringBuffer stringbuffer) &#123; char c0 = hexDigits[(bt &amp; 0xf0) &gt;&gt; 4]; char c1 = hexDigits[bt &amp; 0xf]; stringbuffer.append(c0); stringbuffer.append(c1); &#125; public static void main(String[] args) throws NoSuchAlgorithmException, IOException &#123; File file = new File("D://BaiduNetdiskDownload//Yellowstone.S01E04.720p.FIX字幕侠.mp4"); System.out.println(getMD5(file)); System.out.println(getSha1(file)); System.out.println(getSha256(file)); System.out.println(getSha512(file)); // 77039e4c75e6b5d743fd914e76ee281c List&lt;Long&gt; l1 = new ArrayList&lt;&gt;(1000); // 1247f4d02639e9714f500d4110075f70e5270dbf List&lt;Long&gt; l2 = new ArrayList&lt;&gt;(1000); // 5bb6a5b692d90514fa8df7d5a43f3bfaa3f9d15e191f6347f49bccb395f36ea0 List&lt;Long&gt; l3 = new ArrayList&lt;&gt;(1000); // 4bd6b47d8df7041cd866948a8e2df7d5a87e318f0a5e23ecb91a74fcf55c768d48b743490f89a09cc124b6e07fbae4d791a361f902a0119886a80c7b3d878a64 List&lt;Long&gt; l4 = new ArrayList&lt;&gt;(1000); for (int i = 0; i &lt; 100; i++) &#123; long start1 = System.currentTimeMillis(); getMD5(file); long end1 = System.currentTimeMillis(); l1.add(end1 - start1); long start2 = System.currentTimeMillis(); getSha1(file); long end2 = System.currentTimeMillis(); l2.add(end2 - start2); long start3 = System.currentTimeMillis(); getSha256(file); long end3 = System.currentTimeMillis(); l3.add(end3 - start3); long start4 = System.currentTimeMillis(); getSha512(file); long end4 = System.currentTimeMillis(); l4.add(end4 - start4); &#125; long sum1 = 0; long sum2 = 0; long sum3 = 0; long sum4 = 0; for (Long l : l1) &#123; sum1 += l; &#125; for (Long l : l2) &#123; sum2 += l; &#125; for (Long l : l3) &#123; sum3 += l; &#125; for (Long l : l4) &#123; sum4 += l; &#125; System.out.println(sum1/1000 + " : " + sum2/1000 + " : " + sum3/1000 + " : " + sum4/1000);// 233 : 330 : 493 : 355 &#125;&#125; 测试结果很意外，SHA512 的速度要比 SHA256 快不少，后来 Google 了下，原来是在 64 位 CPU 上 SHA512 比 SHA256 快，而在 32 位 CPU 上运算则是 SHA256 更快。 加盐「在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。」采用的加密方式为md5(md5(password) + salt) ， 其实，以随机字符串对密码加盐仅仅是增加破解密码的难度，增加攻击者的成本。 数字证书有了上面的概念，数字签名、数字证书就很好理解了。 数字签名：信件通过散列函数生成一段定长的信件摘要（即数字指纹），然后通过「非对称加密」私钥对信件摘要加密得到数字签名。那么其他人如何验证数字签名呢？通过公钥对数字签名解密得到摘要文件 digest1，然后对信件使用相同的散列函数得到 digest2，如果 digest1 和 digest2 一致，就说明信件未经篡改。 那么，问题来了，服务端如何将公钥发给客户呢？客户端如何确保该公钥是真实的服务端的公钥而不是某个中间人的公钥（因为每个人都可以自己生成一对公私钥）呢？于是，确保公钥确实是这个证书所有者的数字证书出现了。 数字证书如何确保公钥确实是这个证书所有者的呢？ 数字证书（第三方认证机构 CA 认证公钥）：数字证书包括以下几部分内容： 证书的发布机构及有效期 公钥及证书所有者 签名所使用的算法 指纹及指纹的算法 CA 使用自己的私钥对数字证书加密得到加密后的数字证书，然后服务端发送信件时不光加上自己的数字签名，还会加上 CA 认证的数字证书，而客户端浏览器里已经内置了 CA 的公钥，客户端收到带有数字证书的信件后对数字证书解密即可得到服务端的公钥信息等，然后即可通过服务端的公钥验证该信息。 由于非对称加密很费时，所以实际生产中一般使用非对称加密传输对称加密的密钥，然后服务端与客户端对称加密通信，既保证了安全，又提高了效率。 查看计算机或浏览器本地证书的方法网上很多，运行 certmgr.msc ，下图是我 PC 里本地证书的截图： BASE 64 编码为什么需要 BASE 64 编码？ 计算机中任何数据都是按 ascii 码存储的，而 ascii 码的 128～255 之间的值是不可见字符，而网络中不同的设备（路由器、交换机）对字符处理方式有些不同，这样不可见字符可能被处理错误，所以就把数据先做一个 BASE 64 编码统统变成可见字符，这样出错的可能性就大降低了。而且有些文本协议不支持不可见字符的传递，只能转换成可见字符来传递信息 。 Java 8的java.util套件中，新增了Base64的类别，可以用来处理Base64的编码与解码，用法如下： 1234567891011public class Test &#123; public static void main(String[] args) &#123; Base64.Encoder encoder = Base64.getEncoder(); Base64.Decoder decoder = Base64.getDecoder(); String str = &quot;BASE64编码&quot;; String encodeStr = encoder.encodeToString(str.getBytes()); System.out.println(encodeStr); byte[] decodeStr = decoder.decode(encodeStr); System.out.println(decodeStr.toString()); &#125;&#125; Java 项目中的加密解密 前端 JS 加解密（crypto-js） 后端 Java 加解密]]></content>
      <tags>
        <tag>Java</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任意进制转换]]></title>
    <url>%2F2018%2F07%2F24%2F%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[最初自学编程时撸过一个 36 进制与 10 进制数值批量互转的小工具，今日再看代码时有了新的思考。 短除法回想在学校学习的进制转换方法，这里我使用短除法实现进制转换功能「建议先掏出小本本理清下短除法的步骤」，废话不多说，直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * @param MValue 存储每个 X 项的系数 * @param M M进制 * @param N N进制 * @return String MValue转换为N进制后的（字符串）数值 */public static String M2N(String MValue, int M, int N) &#123; //M、N的值是否在合理范围内 if (M &gt; 36 || M &lt; 2 || N &gt; 36 || N &lt; 2) &#123; System.out.println("仅支持2到36进制间相互转换"); &#125; //将MValue转为lowerCase,并检查其值是否符合规范 String lowerCaseMValue = MValue.toLowerCase(); if (M &lt;= 10) &#123; for (char c : lowerCaseMValue.toCharArray()) &#123; if (!(c &gt;= '0' &amp;&amp; c &lt; (char)(M + 48))) &#123; System.out.println(MValue + "========不是" + M +"进制的数据"); &#125; &#125; &#125; else &#123; char[] chars = lowerCaseMValue.toCharArray(); for (int i=0; i&lt;chars.length; i++) &#123; char tmp = chars[i]; if (!((tmp &gt;= '0' &amp;&amp; tmp &lt;= '9') || (tmp &gt;= 'a' &amp;&amp; tmp &lt; (char)(M + 87)))) &#123; System.out.println(MValue + "========不是" + M +"进制的数据"); &#125; &#125; &#125; List&lt;Integer&gt; lIntNValue = new ArrayList&lt;&gt;(); List&lt;Integer&gt; lIntMVaule = stringToArrayNumber(lowerCaseMValue); List&lt;Integer&gt; duplicateLIntMValue = lIntMVaule; int yushu = 0; //短除法 while (!allEmpty(lIntMVaule)) &#123; for (int i=0; i&lt;lIntMVaule.size(); i++) &#123; int shang = (yushu * M + lIntMVaule.get(i)) / N; yushu = (yushu * M + lIntMVaule.get(i)) % N; duplicateLIntMValue.set(i, shang); &#125; lIntMVaule = duplicateLIntMValue; lIntNValue.add(yushu); yushu = 0; &#125; Collections.reverse(lIntNValue); return arrayNumberToString(lIntNValue); &#125;/* * 检查整型数组是否全为 0 * */public static boolean allEmpty(List&lt;Integer&gt; lIntMVaule) &#123; for (int i : lIntMVaule) &#123; if (i != 0) &#123; return false; &#125; &#125; return true;&#125;/* * 字符串数字转为整型数组 * */public static List&lt;Integer&gt; stringToArrayNumber(String strNum) &#123; List&lt;Integer&gt; lIntNum = new ArrayList&lt;&gt;(); char[] charsNum = strNum.toCharArray(); for (char c : charsNum) &#123; lIntNum.add(getIntFromStr(String.valueOf(c))); &#125; return lIntNum;&#125;/* * 整型数组转为字符串数字 * */public static String arrayNumberToString(List&lt;Integer&gt; lIntNum) &#123; String strNum = ""; for (int i : lIntNum) &#123; strNum += getStrFromInt(i); &#125; return strNum;&#125;/* * 将字符串类型的单个字符转为整型数字 * */public static int getIntFromStr(String str) &#123; return str.charAt(0) &lt;= '9' &amp;&amp; str.charAt(0) &gt;= '0' ? str.charAt(0) - '0' : str.charAt(0) - 'a' + 10;&#125;/* * 将整型数字转为单个字符的字符串 * */public static String getStrFromInt(int value) &#123; String result = null; if (value&gt;=0 &amp;&amp; value&lt;=9) &#123; result = String.valueOf((char)('0' + value)); &#125; else if (value &gt; 9 &amp;&amp; value &lt;36) &#123; result = String.valueOf((char)('a' + value - 10)); &#125; return result; &#125;public static void main(String[] args) &#123; String result = M2N("123y5abc", 36, 10); System.out.println(result); // 82956480888&#125; 空间换时间的思想基于「空间换时间」的思想，我对上面的代码进行了一番修改，利用 HashMap 来存储字符和十进制数值的映射关系，修改 stringToArrayNumber、arrayNumberToString 这两个方法，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public static final HashMap&lt;Character, Integer&gt; INTMAP = new HashMap&lt;&gt;(36);/* * 使用数组更快更简洁：char CHARMAP = &#123;'0', '1', '2', '3', …… ,'y','z'&#125;; */public static final HashMap&lt;Integer, Character&gt; CHARMAP = new HashMap&lt;&gt;(36); static &#123; INTMAP.put('0', 0); INTMAP.put('1', 1); INTMAP.put('2', 2); INTMAP.put('3', 3); INTMAP.put('4', 4); INTMAP.put('5', 5); INTMAP.put('6', 6); INTMAP.put('7', 7); INTMAP.put('8', 8); INTMAP.put('9', 9); INTMAP.put('a', 10); INTMAP.put('b', 11); INTMAP.put('c', 12); INTMAP.put('d', 13); INTMAP.put('e', 14); INTMAP.put('f', 15); INTMAP.put('g', 16); INTMAP.put('h', 17); INTMAP.put('i', 18); INTMAP.put('j', 19); INTMAP.put('k', 20); INTMAP.put('l', 21); INTMAP.put('m', 22); INTMAP.put('n', 23); INTMAP.put('o', 24); INTMAP.put('p', 25); INTMAP.put('q', 26); INTMAP.put('r', 27); INTMAP.put('s', 28); INTMAP.put('t', 29); INTMAP.put('u', 30); INTMAP.put('v', 31); INTMAP.put('w', 32); INTMAP.put('x', 33); INTMAP.put('y', 34); INTMAP.put('z', 35); CHARMAP.put(0, '0'); CHARMAP.put(1, '1'); CHARMAP.put(2, '2'); CHARMAP.put(3, '3'); CHARMAP.put(4, '4'); CHARMAP.put(5, '5'); CHARMAP.put(6, '6'); CHARMAP.put(7, '7'); CHARMAP.put(8, '8'); CHARMAP.put(9, '9'); CHARMAP.put(10, 'a'); CHARMAP.put(11, 'b'); CHARMAP.put(12, 'c'); CHARMAP.put(13, 'd'); CHARMAP.put(14, 'e'); CHARMAP.put(15, 'f'); CHARMAP.put(16, 'g'); CHARMAP.put(17, 'h'); CHARMAP.put(18, 'i'); CHARMAP.put(19, 'j'); CHARMAP.put(20, 'k'); CHARMAP.put(21, 'l'); CHARMAP.put(22, 'm'); CHARMAP.put(23, 'n'); CHARMAP.put(24, 'o'); CHARMAP.put(25, 'p'); CHARMAP.put(26, 'q'); CHARMAP.put(27, 'r'); CHARMAP.put(28, 's'); CHARMAP.put(29, 't'); CHARMAP.put(30, 'u'); CHARMAP.put(31, 'v'); CHARMAP.put(32, 'w'); CHARMAP.put(33, 'x'); CHARMAP.put(34, 'y'); CHARMAP.put(35, 'z');&#125; public static List&lt;Integer&gt; stringToArrayNumber(String strNum) &#123; List&lt;Integer&gt; listIntNum = new ArrayList&lt;&gt;(); char[] charsNum = strNum.toLowerCase().toCharArray(); for (char c : charsNum) &#123; listIntNum.add(INTMAP.get(c)); &#125; return listIntNum;&#125;public static String arrayNumberToString(List&lt;Integer&gt; lIntNum) &#123; String strNum = ""; for (int i : lIntNum) &#123; strNum += CHARMAP.get(i); &#125; return strNum;&#125; 然后最后的测试结果却很令我失望，先是将 1000 万个十进制数转换成 36 进制数，上面两种方式都用时 8 秒，不分胜负；之后我将 10 亿个十进制数转换成 36 进制，结果第一种方法用时 1073 秒，第二种用时 1235 秒。很是郁闷，看来「空间换时间」只适合用在超复杂计算的时候，上面这种简单的计算并不适用。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ResultSet 使用总结]]></title>
    <url>%2F2018%2F07%2F15%2FResultSet%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[唯有疼痛，方可刻骨铭心。 通过 ResultSet.getString() 方法取一个 Oracle 数据库中的 Date 类型的字段，取出的值变成了 2018-7-2 12.12.12.0，着实神奇。 1234567891011121314151617181920212223Statement stm = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);ResultSet rs = stm.executeQuery(sql);if (rs.next()) &#123; System.out.println(rs.getString(2)); System.out.println(rs.getDate(2)); System.out.println(rs.getTime(2));&#125; Statement stm2 = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);ResultSet rs2 = stm2.executeQuery(sql);if (rs2.next()) &#123; System.out.println(rs2.getString(2)); System.out.println(rs2.getDate(2)); System.out.println(rs2.getTime(2));&#125;//运行结果如下：2018-7-2 15.34.48.02018-07-0215:34:482018-07-02 15:34:48.02018-07-0215:34:48 ResultSet 的 Type 属性：Connection 的 Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException 方法; 参数 resultSetType: ​ ResultSet.TYPE_FORWORD_ONLY 结果集的游标只能向下滚动。 ​ ResultSet.TYPE_SCROLL_INSENSITIVE 结果集的游标可以上下移动，当数据库变化时，当前结果集不变。 ​ ResultSet.TYPE_SCROLL_SENSITIVE 返回可滚动的结果集，当数据库变化时，当前结果集同步改变。 参数 resultSetConcurrency： ​ ResultSet.CONCUR_READ_ONLY 不能用结果集更新数据库中的表 。 ​ ResultSet.CONCUR_UPDATETABLE 能用结果集更新数据库中的表。 参考链接：ResultSet 的Type属性 TYPE_FORWARD_ONLY 创建 Statement 的三种类型：最基本的 Statement st = conn.CreateStatement() ​ 只能使用 next() 方法，逐个的读取数据。 可滚动的、可更新的 ResultSet ​ Statement st = conn.createStatement(int resultSetType, int resultSetConcurrency) ； ​ ResultSet 有 insertRow()、deleteRow()、updateRow() 等各种方法，见 ResultSet 源码。 可保持的ResultSet ​ Statement st = conn.createStatement(int resultsetscrollable,int resultsetupdateable,int resultsetSetHoldability) ，见 Connection 类源码； 疼痛总结： 理论与实践并重。最初自学编程时总是看得多，动手少，最后学完很容易忘记，上手写代码脑中一片空白，充满挫败感；后来工作繁忙，便放松了基本理论的学习，又导致在项目开发中踩了不少深坑（其实都是些很基础的小问题），耽误了时间。 注重开发规范。有些同事（包括自己有时也是这样）写起代码来一把梭，全然不顾读代码人的感受，再加上项目都是多人协作，事先没个规范最后出问题 debug 时就是个深坑，出现各种问题，修复这个 bug 时又会出现另一个 bug，掉入不断修复 bug 的漩涡之中。 bug 最终还是要自己修复的。求助他人只是起到点拨作用，开阔自己解决问题的思路，最终问题还是得自己解决的。 源码里面找方法。]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Server 转 Oracle]]></title>
    <url>%2F2018%2F07%2F14%2FSQLServer%20%E8%BD%AC%20Oracle%2F</url>
    <content type="text"><![CDATA[工作中碰到需要把 SQL Server 的数据迁移到 Oracle 的情况，踩坑总结。 一. 使用 SQL Server 本身提供的「导入导出」工具，将 SQL Server 数据转到 Oracle 中环境：64 位 SQL Server、Oracle、「导入导出」工具。 起初使用 32 位 Oracle 数据库，一直导入失败，后换用 64 位 Oracle 数据库后正常。注意：「导入导出」工具也要使用 64 位，否则也会出错。 参考文章：&lt;a href=”https://blog.csdn.net/x541211190/article/details/72842149 将SQLServer表直接导入Oracle数据库（图文教程） 注意： 默认转换有些表和字段的映射会不太准确，一定要一一确认； SQL Server 导入 Oracle 的表和字段有区分大小写； 表的主键、索引等信息都没有自动导入 Oracle 中去。 二. 将转到 Oracle 中的所有表和字段全转为大写由于 Oracle 中的表和字段都是有区分大小写的，而 Oracle 执行 SQL 语句时会自动全部转为大写，所以这里需要将 Oracle 中的表和字段全转为大写，使用如下存储过程批量修改： 123456789101112131415161718192021-- 修改当前用户的所有表所有字段为大写begin DBMS_OUTPUT.ENABLE(1000000); for t in (select table_name tn from user_tables) loop begin for c in (select column_name cn from user_tab_columns where table_name=t.tn) loop begin execute immediate &apos;alter table &apos;||t.tn||&apos; rename column &quot;&apos;||c.cn||&apos;&quot; to &apos;||upper(c.cn); exception when others then dbms_output.put_line(t.tn||&apos;.&apos;||c.cn||&apos;已经存在&apos;); end; end loop; execute immediate &apos;alter table &quot;&apos;||t.tn||&apos;&quot; rename to &apos;||upper(t.tn); exception when others then dbms_output.put_line(t.tn||&apos;已存在&apos;); end; end loop; end; 由于 SQL server 在录入时对录入内容区分大小写，但在查询时对代码不区分大小写，所以可能会出现同样的查询条件，原本在 SQL server 中正常查出结果的换到 Oracle 中却会查询错误的情况。 三. 为 Oracle 中的表手动建立主键、索引等SQL server 和 Oracle 数据类型对应： SQL Server 数据类型 Oracle 数据类型 char(1-2000) CHAR(1-2000) char(2001-4000) VARCHAR2(2001-4000) nvarchar(1-1000) VARCHAR2(1-2000) varchar(1-4000) VARCHAR2(1-4000) date、datetime、smalldatetime DATE dateadd(year,1,a.EffDate) add_months(a.EffDate,12) int NUMBER(10,0) float FLOAT 参考链接：博客园：Oracle和sqlserver数据类型对应 SQL server 和 Oracle 常用函数对应： SQL Server 函数 Oracle 函数 convert(char(20),getdate(),120) to_char(sysdate, ‘yyyy-mm-dd hh24:mi:ss’) CONVERT(varchar(100), GETDATE(), 23) to_char(sysdate, ‘yyyy-mm-dd’) CONVERT(varchar(100), GETDATE(), 24) to_char(sysdate, ‘hh24:mi:ss’) datediff(YEAR,EffDate,getdate()) (extract(year from sysdate)-extract(year from EffDate)) dateadd(year,1,a.EffDate) add_months(a.EffDate,12) isnull(n.cnt, 0) nvl(n.cnt, 0) cast(-1.002 as int) trunc(-1.002) charindex(‘s’,’sdsq’,2) instr(‘sdsq’,’s’,2) substring(‘abcdefg’,2,3) substr(‘abcdefg’,2,3) SQL Server 相关知识点：数据库还原失败「.bak 文件」： ​ 勾选 – 覆盖现有数据库 ​ 取消勾选 – 还原前进行结尾日志备份 ​ 参考文章：SQLserver 备份和还原 失败 SSMS 无法执行大小超过 100M 的 sql 文件： ​ 在 cmd 窗口使用 osql -E -i input_file 命令执行 .sql 文件 ​ 参考文章：sql server 执行上100mb sql sql sql server 无法执行脚本 没有足够的内存继续执行 Oracle 相关知识点：Oracle 数据库创建新用户并授予 DBA 权限： ​ create user abc identified by 123456; ​ grant connect,resource,dba to abc; 为什么 varchar2 很少用： ​ 网上查来的答案：「The NVARCHAR2 is a Unicode-only datatype. Note also that some features won’t work with NVARCHAR2 」，参考链接：Difference between VARCHAR2(10 CHAR) and NVARCHAR2(10) ​ 查看数据库字符集：SELECT * FROM NLS_DATABASE_PARAMETERS; Oracle Date Timestamp 类型区别： Oracle 毫秒的存储必须字段类型为 timestamp(6) – 数字表示存储的毫秒位数 select to_char(systimestamp,&#39;yyyy-mm-dd hh24:mi:ss.ff6&#39;) from dual; -- 2018-07-21 16:40:53.829000]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 导出 sql 文件乱码]]></title>
    <url>%2F2018%2F07%2F06%2FOracle%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A1%A8%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[何为良好生活？陈嘉映说「行之于途而应于心」；路遥也曾说过「只有在无比沉重的劳动中,人才会活得更为充实」。在这个价值流失的年代如何自处，我想很简单，撸起袖子加油干，做好眼前事就行了，在做事行路的过程中自然就会找寻到意义，意义不是空想出来的，而是在实践中产生的。 这篇文章简单记录 Oracle 导出表结构表数据的关键点，使用常用的 plsql 工具。 Export Tables 的三种导出方式使用 plsql 工具导出表结构表数据其实很简单方便，打开 plsql 工具，选择 Tools 菜单栏下面的 Expor Tables 即可。点开你会发现如下界面： 第一种 Oracle Export 是导出为 .dmp 的文件格式，.dmp文件是二进制的，可以跨平台，还能包含权限，效率也很不错，用得最广 。 第二种 SQL Insert 是导出为.sql文件的，可用文本编辑器查看，通用性比较好，但效率不如第一种，适合小数据量导入导出。尤其注意的是表中不能有大字段（blob,clob,long），如果有，会提示不能导出(提示如下： table contains one or more LONG columns cannot export in sql format,user Pl/sql developer format instead)。 第三种是导出为.pde格式的，.pde为Pl/sql developer自有的文件格式，只能用Pl/sql developer自己导入导出，不能用编辑器查看。 需要注意的是： 就算你选择第一种 Oracle Export 方式导出为 .sql 文件，也是可以的，但是最终导出的 sql 文件打开会有乱码，我一开始并不清楚这三种导出方式的区别，使用第一种方式导出为 .sql 文件一直是乱码，浪费了不少时间。 导出的 SQL 文件中文乱码关于导出乱码的问题，网上有很多教程，但都是抄来抄去也写的不清晰，这里基于自己实际解决乱码问题的经验简单记录下： 问题的关键就在于 server、client 端的编码要一致， 将 client 端的编码方式修改为和 server 端一致即可。 Oracle 字符集： ORACLE的字符集名字由三部分组成：NLS_LANG=\_\.\ 比如常见的 nls_lang=AMERICAN_AMERICA.UTF8 ； nls_lang=SIMPLIFIED CHINESE_AMERICA.UTF8 查看 Server 字符集环境： 123456SELECT * FROM NLS_DATABASE_PARAMETERS;-- 我的查询结果如下：PARAMETER VALUENLS_LANGUAGE AMERICANNLS_TERRITORY AMERICANLS_CHARACTERSET AL32UTF8 数据库可用字符集参数设置： SELECT * FROM V$NLS_VALID_VALUES 注意：SELECT * FROM NLS_INSTANCE_PARAMETERS 是表示实例的字符集环境，而不是客户端。 查看 Client 字符集环境： SELECT USERENV(&#39;language&#39;) FROM DUAL; 修改 Client 字符集： 我使用的开发环境是 Windows，所以只写在 Windows 下的操作方法：修改注册表键值永久设置，HKEY_LOCAL_MACHINE/SOFTWARE/ORACLE/KEY_XXXX_home1/NLS_LANG，将值修改为 AMERICAN_AMERICA.AL32UTF8 后导出的 sql 文件编码正确，显示正常。 参考文章：Oracle 字符集基础知识]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018上半年复盘]]></title>
    <url>%2F2018%2F06%2F30%2F2018%E4%B8%8A%E5%8D%8A%E5%B9%B4%E5%A4%8D%E7%9B%98%2F</url>
    <content type="text"><![CDATA[星球作业：2018 上半年复盘 「不写新年计划」，这是我从学生时代就一直坚持的，因为我讨厌这种行为。每当老师要求我们写下自己的小目标时甚至贴在自己的桌上时，我总是非常厌恶的，我觉得这种行为幼稚而无用，因为我觉得只有将自己的计划和理想牢牢记在心里并不断提醒自己，才能真正促进自己一步一步去接近自己的目标，而这种写在小纸片上的行为只会成为自己没有实现目标时被人贻笑的把柄，成为自己是个 loser 的铁证。 然而，随着成长与认知能力的提升，逐渐认清了自己拒绝写新年计划的本质其实是害怕失败时被人耻笑。去年加入了帅张小密圈，看到大家都在写年终总结与新年计划，自己也想开始做出改变，所以在 2017/12/31 认真写下了自己人生中的第一个新年计划： 转行 Java 后端开发； 学习理财知识，着手基金定投实战； 学会游泳，提高英语听说能力； 读完 5 本好书（非职业技能类）； 找个女朋友。 今年 3 月底离职来到上海，转行 Java 开发，由于非科班非应届生的尴尬身份，又缺少实际的开发经验，工作自然不好找，上海生活压力也大，只能放弃之前进入互联网公司收获高薪的美好愿望，加入一家保险金融行业的外包公司，工资仅够养活自己，但也算是成功转行 Java 开发吧，现在老大也挺器重我，给我提前转正了，总之先加油好好干。 至于基金定投实战，目前还在坚持，虽说最近的股灾也让我头疼，但好歹我投的钱少，继续跌下去我也还能坦然接受，这次的股灾也能很好的让我看清自己能承受的亏损率在那个范围，下半年还得接着基金定投实战的机会继续系统的学习点儿理财知识。说到这儿，我还在上半年买了点儿加密货币，曾经翻了一番多，但现在又跌回来了，我做的是价值投资，长期持有，也借着买币的机会学习了解了区块链技术的基础概念，现在也能和人瞎侃了，多说一句，区块链技术真的还非常不成熟，短时间还无法迎来区块链应用的春天。 上半年读完了《三体3》、《哲学家们都干了些什么》和《全新思维：决胜未来的 6 大能力》这三本书，获益匪浅。目前正在看《大路：高速中国里的工地纪事》、《佛祖都说了些什么》、《禅与摩托车维修技术》，后面还有《何为良好生活：行之于途而应与心》等很多的好书要看，总之，现在已经慢慢养成了爱阅读的习惯，阅读也的确让我收获很多，这是个好的改变。 游泳、英语、女票，这三个目标真的好难，今年夏天老是下雨，还没找个游泳馆去学习。英语的学习我觉得还是要和应用结合在一起，而我目前主要也就是 Google 搜索和阅读英语文章，后面继续多学多用吧，多逛国外网站多读英语文章。女票，哪有那么好找，继续努力吧！ 下面简单说说自己上半年的改变。 我的执行力更强了，我孤身一人来到上海转行 Java，我搭建自己的博客尝试写作，我开始使用云笔记记录整理自己的知识库，现在我可以约束自己朝着目标去一点一点前进，去执行。 我更加热爱生活了，我开始学习做菜，周末有时还叫上朋友过来尝尝我的厨艺；学习拍照，发现记录周围的美好，技术毕竟是冰冷的，程序员千万别一头扎进代码里而忽视了身边的朋友，周围的美景；每天把自己收拾干净利索，积极拥抱每一天的生活，珍惜当下的时光。 我更加热爱阅读了，阅读使我思考，思考使我快乐，通过阅读可以收获知识，而知识可以让我生活变得更加充实有趣。 时间过的真快，下半年，继续加油！]]></content>
      <tags>
        <tag>成长总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F06%2F22%2Fgit%2F</url>
    <content type="text"><![CDATA[「子路有闻，未之能行，唯恐有闻。」 深感自己学习中缺乏动手实践，十分惭愧。本文为最近工作中学习踩坑总结，每一个问题情景都是在工作中真实出现，每一条指令都是亲自执行验证过的，记录在此方便日后查阅翻看。 Git 基本概念Git 专用名词： Remote：远程仓库 Repository：本地仓库 Stage：暂存区 Workspace：工作区 git 版本管理中，文件的四种状态： untracked： unmodified： modified： staged： Git 实战 Tips忽略指定文件「JdbcUrl.java」:场景：多个开发小组需要使用不同的 Jdbc 配置（如，我需要通过外网 IP 访问数据库，而测试环境需要内网 IP 访问数据库），项目组规定任何人不得提交修改的 JdbcUrl.java 文件，这样每次提交代码需要手动 revert 该文件，多分支切换开发时很麻烦。 提交代码时忽略此文件方法如下： .gitignore：仅适用于文件从未提交过「.gitignore 规则只能忽略那些 untracked 状态的文件」 git update-index --assume-unchanged PATH：提交时忽略此文件 如想恢复该文件：git update-index --no-assume-unchanged -- path 找出所有被忽略的文件：git ls-files -v | grep &#39;^h\ &#39; git rm --cached PATH：已经推送（push）过的文件，想从git远程库中删除，并在以后的提交中忽略，但是却还想在本地保留这个文件 注意：使用上述方法只能在提交代码时忽略指定文件，但每次从远程仓库 pull 代码时还是会将 JdbcUrl.java 文件合并到当前本地分支引起冲突，如何解决呢？ 合并代码时忽略指定文件方法如下： 选定 ours 驱动，git config --global merge.ours.driver true 在要被 merge 的分支上创建 .gitattributes 文件（注意：Windows系统无法创建名为「.xx」的文件，可在git bash 里使用 touch 命令创建 .gitattributes 文件），并且在文件中置顶不merge的文件名，.gitattributes 文件内容为：index.php merge=ours 合并时驱动选择 ours 当前工作只进行一半，没法提交，但必须切换分支：场景：需求分支上的开发工作进行一半，突然收到紧急 bug，需要放下当前工作切换分支修复 bug，此时可以将当前工作暂存到 stash git stash：工作现场保存到 stash，此时 Workspace 就是干净的，便能成功切换分支 git stash list：查看 stash git stash pop：将当前分支的最后一次缓存内容释放出来，但刚才的记录不存在 list 中 git stash apply：将当前分支的最后一次缓存内容释放出来，但刚才的记录还在 list 中 git stash drop stash@{0} ：删除第一个队列 git stash clear ：清空所有内容 本地和远程仓库的文件冲突push 代码时发生冲突，这是由于之前 push 的代码在远端发生改变，它不允许你直接把你的代码覆盖上去。此时在提交之前你需要将远端的改变合并到本地上。 git fetch origin feature/RBWMII-612:tmpRBWMII-612：将远程 origin 仓库的 feature/RBWMII-612 分支代码下载到本地 tmpRBWMII-612 分支 git diff tempRBWMII-612 git merge tempRBWMII-612 解决冲突：Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，修改后保存，再提交 最后删除 tmpRBWMII-612 分支 Git 文件回滚 git reset --hard commit_id \&lt;path\&gt; ：指定文件退/进到指定 commit 的 sha 码 git reset --hard HEAD^ ：回退到上个版本 从其他分支 merge 指定文件到当前分支git checkout source_branch \&lt;path\&gt; 注意：使用 git checkout 某文件到当前分支时，会将当前分支的对应文件强行覆盖 SSH 免密登录当然，免密登录的方式不止一种，如：在 .gitconfig 文件中配置 [credential] helper = store。 大神阮一峰写过 SSH 的文章，通熟易懂，我就直接直接拿来主义了：SSH原理与运用（一）：远程登录 SSH 通信原理首次登录目标主机，目标主机发送公钥指纹（对公钥进行 MD5 计算变成一个 128 位公钥指纹）到用户，用户自行核对（一般目标主机会在自己的网站上贴出公钥指纹），用户决定接受远程主机的公钥，然后输入密码。 每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常 /etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。 SSH 远程登录用户上传公钥到远程主机（Github，Gitlab……），之后客户登录远程目标主机，远程主机向用户发送一段随机字符串，用户用自己的私钥加密后返回远程主机，远程主机使用用户公钥解密验证。 注意：SSH 免密登录和用户名密码登录方式只能任取一种，如果上传公钥到远程主机，则无法再使用用户名密码方式登录验证。新来同事用我的 Gitlab 账号登录 pull 代码，一直失败，后来删除 Gitlab 上的公钥后，方可成功登录拉取代码，后来验证，在 Github 上也是如此。 学习参考链接：常用 Git 命令 廖雪峰 Git 教程]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为何网上垃圾资讯越来越多]]></title>
    <url>%2F2018%2F06%2F15%2F%E4%B8%BA%E4%BD%95%E7%BD%91%E4%B8%8A%E5%9E%83%E5%9C%BE%E8%B5%84%E8%AE%AF%E6%B3%9B%E6%BB%A5%2F</url>
    <content type="text"><![CDATA[某种程度上讲，互联网使得我们小老百姓的权力相比过去有所增加，使得普通人的需求得到关注和满足，而大部分人的天性就是懒于思考的，迷恋于那些非常容易就能获得满足感的事物…… 互联网的快速发展，使得我们每个人都有了发声的渠道，有了表达自己的平台，「再小的个体，也有自己的品牌」。 某种程度上讲，相比过去，我们的权力在变大，我们的需求在被各种公司关注研究，他们做市场调研、做技术积累沉淀、做大数据分析、做人工智能，他们费尽心力努力打造出我们需要的产品，来满足我们的需求。我们似乎真的在网络上得到了「顾客就是上帝」般的高质量服务，我们吃喝玩乐都能轻轻松松的在手机上的几个 APP 里完成。当然，公司设计出这些满足我们需求的产品，就是为了赚钱，赚钱也是现在社会的主旋律，而要想打造出用户喜爱的产品，就一定弄清用户的需求、了解用户的心理。 互联网公司的用户就是普罗大众，要弄懂普通人的需求，得先了解人性。 回想一下，每当我们忍不住刷手机时，到底是在想获得什么？刷微博、刷朋友圈、刷各种圈子、看新闻、读公号文章、小视频，在刷手机的那一刻，仿佛时间过的很充实，我又看到了好多新鲜事、学到了好多知识、还有朋友圈里获得的不真实的优越感或认同感、游戏中得到的成就感，总结起来，其实都是为了获得一种「满足感」。 而我们大部分人天性懒于思考（包括此刻的我，这些文字我写的很慢很艰难），这也导致了我们对很多的东西缺乏辨别能力，很容易被一些标题党或泛滥的爱国主义民族大义等垃圾新闻内容戳中 G 点，这些资讯内容并没有任何价值，甚至很多的新闻内容都是伪造的假新闻，却大量的占用了我们的时间。如今信息技术水平高速发展，这些资讯内容的生产也已经形成的完善的产业化，按照一定的套路拼凑点素材就能快速写出一篇文章，甚至很多新闻稿子是机器流水化生产的按照一定的套路拼凑点素材就能快速写出一篇文章，甚至很多新闻稿子是机器流水化生产的（参见微信公众号「我就 BB 怎么了」的文章说点劲爆的）。 如今，以「头条」系为代表的产品，今日头条、趣头条等各种资讯类 APP，里面充满着标题党、爱国主义、民族大义等垃圾内容，真正有价值的新闻却少之又少，还有像抖音、快手一类的短视频 APP，这些小视频看完了简直让我怀疑人生，爽了一时，却毫无收获。这些科技公司通过技术手段分析用户行为，从而提供智能推送服务，牢牢抓住用户的空闲时间，阻碍用户真正的思考，侵占用户宝贵的时间。 我认为，「独立思考」是我们生而为人的尊严之一，然而如今却有越来越多的人放弃了它，甚至还有些「聪明的家伙」为了私利在助长人们放弃它。]]></content>
      <tags>
        <tag>瞎BB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取properites配置文件信息]]></title>
    <url>%2F2018%2F06%2F11%2F%E8%8E%B7%E5%8F%96properites%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[最近在项目中看到别人使用 ResourceBundle 获取 properites 配置文件信息，感觉挺方便的，学习记录于此。 通过 getResourceAsStream 方式获取getResourceAsStream 这个函数寻找文件的起点是 JAVA 项目编译之后的根目录 。 123456789101112131415161718public class ConfigReader &#123; public static String getProperty(final String propertyName) &#123; return ConfigReader.reader.properties.getProperty(propertyName); &#125; private static final Properties properties = new Properties(); public static final ConfigReader reader = new ConfigReader(); private ConfigReader() &#123; try &#123; //InputStream in = this.class.getClassLoader().getResourceAsStream(&quot;/config.properties&quot;); InputStream in = this.class.getClassLoader().getResourceAsStream(&quot;config.properties&quot;); this.properties.load(in); in.close(); &#125; catch (IOException e) &#123; logger.error(e); &#125; &#125;&#125; 参考链接：（转）java getResourceAsStream的使用方法 通过 ResourceBundle 方式获取只需要下面两行代码就可以搞定： ResourceBundle bundle = ResourceBundle.getBundle(file); String value = bundle.getString(key); 网上说法，「ResourceBundle类通常是用于针对不同的语言来使用的属性文件。根据当前系统的国别语言信息（也可以程序指定），然后获取相应的properties文件的内容」。 我的理解是：需要程序动态获取 .properties 配置文件时使用 ResourceBundle 更加方便，但如果是获取静态的全局配置文件使用 getResourceAsStream 就好，加载一次，就存储在配置 Java 类里]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦魇：项目启动失败]]></title>
    <url>%2F2018%2F06%2F08%2F%E4%B8%BA%E4%BD%95%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[刚从事软件开发工作时，某踩坑无数的同事告诉我：软件开发嘛，一开始就是熟悉各种工具的使用和踩坑。而启动项目失败就是 newbie 的梦魇，记得第一天入职搭建项目就花了我整整一天，加班搞到晚上才将项目勉强启起来。 项目启动失败怎么办：项目启动失败可以说是没有经验的新人的梦魇，为什么别人可以正常启动运行的项目一放到我的电脑上就会报各种神奇的错误，明明代码一样，运行环境一样。今天也来总结一波我的踩坑之旅，将那些曾经踩过的坑及解决方法总结记录下来。 其实，项目启动中的大部分的报错都是可以在网上找到解决方法的，遇到报错不要紧张、不要慌，冷静而有条理的一步步排查，总能解决的。踩的坑多了，并时常自我总结，自然就会有解决问题的方法和思路了。 Q：导入 Java 项目出现 JRE System Library(unbound) A：绑定 JRE 即可 Q：eclipse 同一 workspace 下的多个工程使用的 jdk 版本不一致 A： eclipse 可以给每个工程单独配置 jdk，修改 eclipse 工程 jdk 版本 Q： Tomcat 端口被占用 A：以管理员身份运行 cmd，执行命令，找出占用 8080 端口的进程：netstat -ano | findstr 8080，杀死该进程：taskkill /F /pid 3484 Q：tomcat启动时出现了Failed to start component [StandardEngine[Catalina].StandardHost[localhost]] A：servlet-api.jar 包与 tomcat/lib 下的包冲突 Q： Tomcat启动异常：A child container failed during start A：检查是否缺少 jar 包，曾经一次缺少 jsp-api.jar 包报了这个错误 Q：tomcat 启动时某个类找不到 A：该类对应的 jar 包是否有部署到 tomcat，是否改类的 .java 文件没有编译成 .class 文件 Q：The resource is not on the build path of a javascript project A：Configure &gt; Convert to JavaScript Project…. Q：eclipse 无法编译项目，各种配置都检查了没有问题 A：关闭当前 workspace，重新新建一个 workspace 并导入项目，然后就 ok 了。所以啊，有的时候重启大法、更换 eclipse、更换 tomcat 等简单粗暴的方法是真的可以解决不少问题的。 下面是使用 eclipse 工具踩过的坑：Q：eclipse debug 不起作用：突然，eclipse工具无论怎么设置断点，debug不起作用。 A：关闭 skip all breakpoints 即可，如图： Q：eclipse出现updating error reports database一直运行解决方案 A： Q：Eclipse的卡顿、启动慢、一直 building A：这篇博文写的不错：Eclipse的设置、调优、使用（解决启动卡顿等问题） 神奇的 Maven，你不想了解下么大神牛逼，写的通俗易懂，直接贴过来，跟着刚哥深入学maven（通俗易懂） maven 镜像配置的两种方式： setting.xml 中配置，对所有 maven 工程有效； pom.xml 中配置，只对当前工程有效。 工作项目中一般会在 pom.xml 里配置多个环境，如： 12345678910111213141516171819202122232425262728&lt;profiles&gt; &lt;profile&gt; &lt;!-- 开发环境 --&gt; &lt;id&gt;DEV&lt;/id&gt; &lt;properties&gt; &lt;EnvID&gt;DEV&lt;/EnvID&gt; &lt;variable2&gt;value2&lt;/variable2&gt; …… &lt;/properties&gt; &lt;!-- 默认激活本环境 --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;!--集成环境 --&gt; &lt;id&gt;SIT&lt;/id&gt; &lt;properties&gt; &lt;EnvID&gt;SIT&lt;/EnvID&gt; &lt;variable2&gt;value2&lt;/variable2&gt; …… &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; ……&lt;/profiles&gt; SysConst.properties 文件如下： 123EnvID=$&#123;EnvID&#125;variable2=$&#123;variable2&#125;…… 在资源文件(SysConst.properties)中放置 pom.xml 预先设置的变量，在执行 mvn package 时就会自动将变量替换为真实值。 日常报错总结：ERROR：Unsupported major.minor version 52.0 Solution：执行代码的 jdk 版本 低于 编译的 jdk 版本 ERROR：Excel 导入（POI）异常 Cannot get a text value from a numeric cell Solution：试图从一个数字类型的Cell读取出一个字符串并写入数据库时，就会出现Cannot get a text value from a numeric cell的异常错误。 ERROR：java.sql.SQLException: ORA-01830: 日期格式图片在转换整个输入字符串之前结束: Solution：如果程序或者数据库报错信息这个的话，一定是其中一个字段或者属性的值出现类似于 2005-10-01 12:01:01.0’ 后面多了一个 .0 这个格式。解决方法就是干掉后面的 .0 参见文章如下： 「如何在properties文件中获取maven的 pom.xml 的键值」 「pom.xml使用多套环境及变量获取」 「使用Eclipse新建一个Maven Project时settings配置的mirror仓库地址无法覆盖默认地址导致打包失败」]]></content>
      <tags>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习方法]]></title>
    <url>%2F2018%2F05%2F21%2F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[某大 V 说过：「看到好的文章，别收藏，一字不差的认真读一遍」 微信公众号看到一篇关于「学习方法论」的文章，写的很好，是我认可且适合我的学习方法，记录在这里。 1. 深入理解基本概念学习任何领域新知识，最恰当的做法就是深入学习最基本的概念，单点突破。概念就是在新领域与别人对话的共同语言。比如学习 Java 编程，你当然得知道什么是变量、什么是循环、什么是类、什么是对象、什么是方法…… 如今互联网上信息过载，各类质量参差不齐的学习资源唾手可得，可惜大部分人缺乏辨识胡乱收藏到网盘，看看这个视频又瞄瞄那个网课，最后缺乏系统思考而迟迟无法踏入编程的大门，这也就是我最初自学编程时的窘态，胡乱收藏各种牛逼的文章和开源代码，却因为基础不够扎实，从来没真正弄懂那些牛逼的点。 2. 发现联系，理清脉络当深入理解了基本概念后，便能跟行业内的人交流并理解他的意思了，这时需要不断的强化练习，将一个个离散的概念点串起来，编织成自己的知识网络，融会贯通。 这时就可以自己尝试去实现一些东西，将自己所学的知识运用起来，解决工作生活中的实际问题，比如 Java 学完基础语法后自己实现个小的项目，即使只是一些简单的工具类「文件递归查找、字符串处理等」也是可以的。 3. 注重细节，踩坑总结运用新领域所学知识并去解决实际问题过程中，一定会遇到问题，有些可能是别人遇到过能在网上查到的，也有些可能是别人没遇到过的，这时就需要根据自己的经验判断去摸索解决问题的办法，理清思路，注重细节，一坑一坑的踩过去，最后再将解决此问题的过程方法记录总结下来，与大家分享共同进步。 4. 学习是件有意思的事情有人说，学习很苦，也有人说，学习很快乐，而我觉得学习是这世上少有的有意思的事情之一，因为学习总能让我发现新的东西，发现更宽广的世界，让自己能从这狭隘的世界抽身出去看到更广阔更美好的事物！ 学习参考链接方法论|进入数字货币和区块链的路线图]]></content>
      <tags>
        <tag>瞎BB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建自己的工具箱]]></title>
    <url>%2F2018%2F05%2F15%2F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%B7%A5%E5%85%B7%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[「工欲善其事，必先利其器。」 有幸看到一篇名为《给年轻程序员的几条建议》的文章，感觉很受益，并开始思考如何打造自己的工具箱。 过去我总认为工具不重要，需要使用时拿来用即可，使用任何工具都无所谓，只要最终能达到我的目的就可以了，现在才领悟过来，熟练使用一款工具会大大提升自己的工作效率。 编辑器：「notepad++」，因为开源，因为免费，因为小巧轻便。 知识库管理：目前使用「有道云笔记」做信息采集和笔记，使用 「Typora 」工具写博客文章。 文件搜索：「everything」，小巧高效的文件搜索工具。 密码管理器：「keepass」，我觉得每个人都应该了解并使用一款密码管理器，解决经常忘记密码的烦恼。 虚拟机软件：「VMware」，Linux 是必须要学要使用的，当然是装虚拟机啦。 Windows 系统备份垃圾清理工具：「Dism++」，功能强大，绿色干净。 Java 反编译工具：「jd-gui」，小巧快速。当然也可以使用 Eclipse 插件 JD-Eclipse 。 文件比较工具：「diffmerge」。 远程桌面工具：「TeamViewer」，免费（个人版）好用。 快捷键是个好东西，应当尽量使用熟悉起来，可以大大改善软件的使用体验，提高生产效率。]]></content>
      <tags>
        <tag>瞎BB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2018%2F05%2F14%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[分而治之 动态规划]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库锁表怎么办？]]></title>
    <url>%2F2018%2F05%2F11%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E8%A1%A8%E6%80%8E%E4%B9%88%E5%8A%9E%2F</url>
    <content type="text"><![CDATA[日常开发中出现数据库锁表的情况时，不但影响自己开发，还会影响他人的开发测试，应当立即定位到被锁的表，并执行解锁操作。 Oracle 数据库锁表查询及解锁12345678-- 查询 SQL 如下：select dbaobj.owner, dbaobj.object_name, s.sid, s.serial#, lckobj.locked_mode from v$locked_object lckobj, dba_objects dbaobj, v$session swhere lckobj.object_id = dbaobj.object_id and lckobj.session_id = s.sidorder by s.logon_time;-- 解锁方法：alter system kill session &apos;sid,serial#&apos;; dba_objects 视图：记录数据库中所有对象 v$locked_object 视图 ：记录当前系统中哪些对象正被锁定 v$session 视图：记录所有会话信息 数据库锁分类按照锁的内容上区分：表锁、页锁、行锁 按照锁的性质上区分：共享锁、排他锁 / 独占锁、更新锁 当执行 select 时，加共享锁，当执行 insert，update，delete 等操作时，加排他锁 数据库隔离级别 脏读：对于两个事务T1，T2，T1读取了已经被T2更新但还没有提交的字段，之后，若T2回滚，T1读取到的内容就是临时无效的内容。 不可重复读：对于事务T1，T2，T1需要读取一个字段两次，在第一次和第二次读取之间，T2更新了该字段，导致T1第二次读取到的内容值不同。 幻读： 事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。 幻读与不可重复读之间的区别是幻读强调的是新增或删除,而不可重复读强调的是修改。比如Mary两次查工资，中间有人改过工资，则两次结果不一样，这就是不可重复读。Mary要查工资一千的人数，第一次查到了10个，中间有人增加了一条工资为一千的人，下次查的时候就变成了11个，好像第一次查询的是幻觉一样。 事务的 4 个隔离级别： read uncommitted：可以读取已由其他事务修改但未提交的行； read committed：不能读取已由其他事务修改但未提交的行；其他事务可以在当前事务的各个语句之间更改数据，从而产生不可重复读取和幻读数据； repeatable read：不能读取已由其他事务修改但未提交的行，并且指定，其他任何事务都不能在当前事务完成之前修改当前事务读取的数据；其他事务可以插入与当前事务语句的搜索条件相匹配的新行，如果当前事务随后重复执行该语句，会检索新行，产生幻读； serializable：所有事务只能一个接一个串行执行，不能并发。 Oracle 支持两种隔离级别：read commited、serializable，默认的事务隔离级别是 read commited 乐观锁与悲观锁Java 开发中经常看到乐观锁，那么到底什么是乐观锁，什么是悲观锁呢？ 悲观锁：数据库实现。共享锁、排他锁都属于悲观锁，Java 关键字 synchronized 也属于悲观锁。 乐观锁：自己实现。操作数据时，不加锁，进行更新后，再去判断是否冲突了。举例如下 1231. 查询出商品信息，select (status,version) from t_goods where id=#&#123;id&#125;2. 根据商品信息生成订单3. 修改商品 status 为 2，update t_goods set status=2,version=version+1 where id=#&#123;id&#125; and version=#&#123;version&#125;; 参考链接Oracle 锁表问题处理 数据库隔离级别]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于写博客]]></title>
    <url>%2F2018%2F05%2F11%2F%E5%85%B3%E4%BA%8E%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[3 W 法是个分析问题的好方法，为了让自己更好的将「写博客」这件小事坚持下去， 尝试用 3 W 法对「怎样写好博客」这个问题作出回答，记录于此。 为什么写博客「记录世界记录你」，作为自己日常工作生活的一种记录方式。本来过去的我是一个非常活在未来的人，不喜欢回忆过去，也不喜欢拍照记录那些当下的幸福瞬间，总觉得更美好的东西永远在未来。可能现在年龄大了，也时常回忆起过去的事情，而且现在的我觉得，时间真的是一种美妙的东西（看完《三体》影响我很多，使我睁眼看到了时间的柔美）。有着过去珍贵的记忆、对当下生活的珍惜和对未来的美好想象，这才是一种更加丰满健全的生活态度。而人的记忆却并不那么可靠，所以从此刻开始，每当有些值得记录的事情或自己的所思所想，我都会记录于此。 「个人表达」能力在当今社会变得越来越为重要，而这恰恰是我非常欠缺的。自己是个相对内向（不高兴时一个人静静呆着就能积攒正能量开始新的一天）的人，没有才艺，不善社交，语言表达能力弱，所以「写作」应该就是一种最适合自己的表达方式了 。 「职业素养」，作为一个程序员，你怎么能没有自己的博客呢？写博客对码农的好处与必要性，网上已经有很多讨论了：加强记忆、加深对技术点的理解、倒闭输出成长大牛。 写什么内容首先当然就是技术相关的文章，写一些自己学习技术的过程和方法，总结工作学习中踩过的那些坑。 然后就是写一些自己日常的小思考。 准备怎么写技术类文章的写作，充分发挥程序员 CTRL + C 和 CTRL + V 的特长，记录学习过程（环境搭建、学习笔记）和踩坑经验（日常问题点及网上查找到的解决方法），即使是 CTRL + C/V 其实也是对自己思维的一种整理，对知识点的再吸收，解决问题经验的一种积累，长期坚持，相信也能慢慢写出高质量的博文。 个人小杂文的写作，初期当然就是瞎写啦，想到什么写什么。 关于坚持年龄越大就越会懂得坚持的力量，如何将写博客这件小事坚持下去呢？ 降低期望，不要太过在意自己写的文章烂，写的烂总比不写要强吧。 与人分享自己的文章，这样是对自己的一个激励反馈，也能发现自己文章的不足之处和提高的方向。 学习相关写作技巧，提高文章质量。 傻傻等待，傻傻等春暖花开。]]></content>
      <tags>
        <tag>瞎BB</tag>
      </tags>
  </entry>
</search>
