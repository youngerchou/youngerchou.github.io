<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据库索引 B+ 树]]></title>
    <url>%2F2018%2F08%2F03%2FB%E6%A0%91%2F</url>
    <content type="text"><![CDATA[红黑树B 树B+ 树在 SSD 相对在服务器端普及的今天，为什么大部分数据库还是用 B/B+ 树实现的？ B+树的设计：把树的上面几层放在内存里，尽量减少外存访问次数；然后把数据按页存储，每次读写单元都是一个页。这两点现在依然很好的贴合SSD的特征。 从机械硬盘到固态硬盘后，b树怎么办？]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习方法]]></title>
    <url>%2F2018%2F08%2F03%2F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[某大 V 说过：「看到好的文章，别收藏，一字不差的认真读一遍」 微信公众号看到一篇关于「学习方法论」的文章，写的很好，是我认可且适合我的学习方法，记录在这里。 1. 深入理解基本概念学习任何领域新知识，最恰当的做法就是深入学习最基本的概念，单点突破。概念就是在新领域与别人对话的共同语言。比如学习 Java 编程，你当然得知道什么是变量、什么是循环、什么是类、什么是对象、什么是方法…… 如今互联网上信息过载，各类质量参差不齐的学习资源唾手可得，可惜大部分人缺乏辨识胡乱收藏到网盘，看看这个视频又瞄瞄那个网课，最后缺乏系统思考而迟迟无法踏入编程的大门，这也就是我最初自学编程时的窘态，胡乱收藏各种牛逼的文章和开源代码，却因为基础不够扎实，从来没真正弄懂那些牛逼的点。 2. 发现联系，理清脉络当深入理解了基本概念后，便能跟行业内的人交流并理解他的意思了，这时需要不断的强化练习，将一个个离散的概念点串起来，编织成自己的知识网络，融会贯通。 这时就可以自己尝试去实现一些东西，将自己所学的知识运用起来，解决工作生活中的实际问题，比如 Java 学完基础语法后自己实现个小的项目，即使只是一些简单的工具类「文件递归查找、字符串处理等」也是可以的。 3. 注重细节，踩坑总结运用新领域所学知识并去解决实际问题过程中，一定会遇到问题，有些可能是别人遇到过能在网上查到的，也有些可能是别人没遇到过的，这时就需要根据自己的经验判断去摸索解决问题的办法，理清思路，注重细节，一坑一坑的踩过去，最后再将解决此问题的过程方法记录总结下来，与大家分享共同进步。 4. 学习是件有意思的事情有人说，学习很苦，也有人说，学习很快乐，而我觉得学习是这世上少有的有意思的事情之一，因为学习总能让我发现新的东西，发现更宽广的世界，让自己能从这狭隘的世界抽身出去看到更广阔更美好的事物！ 学习参考链接方法论|进入数字货币和区块链的路线图]]></content>
      <tags>
        <tag>瞎BB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦魇：项目启动失败]]></title>
    <url>%2F2018%2F08%2F03%2F%E4%B8%BA%E4%BD%95%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[刚从事软件开发工作时，某踩坑无数的同事告诉我：软件开发嘛，一开始就是熟悉各种工具的使用和踩坑。而启动项目失败就是 newbie 的梦魇，记得第一天入职搭建项目就花了我整整一天，加班搞到晚上才将项目勉强启起来。 项目启动失败怎么办：项目启动失败可以说是没有经验的新人的梦魇，为什么别人可以正常启动运行的项目一放到我的电脑上就会报各种神奇的错误，明明代码一样，运行环境一样。今天也来总结一波我的踩坑之旅，将那些曾经踩过的坑及解决方法总结记录下来。 其实，项目启动中的大部分的报错都是可以在网上找到解决方法的，遇到报错不要紧张、不要慌，冷静而有条理的一步步排查，总能解决的。踩的坑多了，并时常自我总结，自然就会有解决问题的方法和思路了。 Q：导入 Java 项目出现 JRE System Library(unbound) A：绑定 JRE 即可 Q：eclipse 同一 workspace 下的多个工程使用的 jdk 版本不一致 A： eclipse 可以给每个工程单独配置 jdk，修改 eclipse 工程 jdk 版本 Q： Tomcat 端口被占用 A：以管理员身份运行 cmd，执行命令，找出占用 8080 端口的进程：netstat -ano | findstr 8080，杀死该进程：taskkill /F /pid 3484 Q：tomcat启动时出现了Failed to start component [StandardEngine[Catalina].StandardHost[localhost]] A：servlet-api.jar 包与 tomcat/lib 下的包冲突 Q： Tomcat启动异常：A child container failed during start A：检查是否缺少 jar 包，曾经一次缺少 jsp-api.jar 包报了这个错误 Q：tomcat 启动时某个类找不到 A：该类对应的 jar 包是否有部署到 tomcat，是否改类的 .java 文件没有编译成 .class 文件 Q：The resource is not on the build path of a javascript project A：Configure &gt; Convert to JavaScript Project…. Q：eclipse 无法编译项目，各种配置都检查了没有问题 A：关闭当前 workspace，重新新建一个 workspace 并导入项目，然后就 ok 了。所以啊，有的时候重启大法、更换 eclipse、更换 tomcat 等简单粗暴的方法是真的可以解决不少问题的。 下面是使用 eclipse 工具踩过的坑：Q：eclipse debug 不起作用：突然，eclipse工具无论怎么设置断点，debug不起作用。 A：关闭 skip all breakpoints 即可，如图： Q：eclipse出现updating error reports database一直运行解决方案 A： Q：Eclipse的卡顿、启动慢、一直 building A：这篇博文写的不错：Eclipse的设置、调优、使用（解决启动卡顿等问题） 神奇的 Maven，你不想了解下么大神牛逼，写的通俗易懂，直接贴过来，跟着刚哥深入学maven（通俗易懂） maven 镜像配置的两种方式： setting.xml 中配置，对所有 maven 工程有效； pom.xml 中配置，只对当前工程有效。 工作项目中一般会在 pom.xml 里配置多个环境，如： 12345678910111213141516171819202122232425262728&lt;profiles&gt; &lt;profile&gt; &lt;!-- 开发环境 --&gt; &lt;id&gt;DEV&lt;/id&gt; &lt;properties&gt; &lt;EnvID&gt;DEV&lt;/EnvID&gt; &lt;variable2&gt;value2&lt;/variable2&gt; …… &lt;/properties&gt; &lt;!-- 默认激活本环境 --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;!--集成环境 --&gt; &lt;id&gt;SIT&lt;/id&gt; &lt;properties&gt; &lt;EnvID&gt;SIT&lt;/EnvID&gt; &lt;variable2&gt;value2&lt;/variable2&gt; …… &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; ……&lt;/profiles&gt; SysConst.properties 文件如下： 123EnvID=$&#123;EnvID&#125;variable2=$&#123;variable2&#125;…… 在资源文件(SysConst.properties)中放置 pom.xml 预先设置的变量，在执行 mvn package 时就会自动将变量替换为真实值。 日常报错总结：ERROR：Unsupported major.minor version 52.0 Solution：执行代码的 jdk 版本 低于 编译的 jdk 版本 ERROR：Excel 导入（POI）异常 Cannot get a text value from a numeric cell Solution：试图从一个数字类型的Cell读取出一个字符串并写入数据库时，就会出现Cannot get a text value from a numeric cell的异常错误。 ERROR：java.sql.SQLException: ORA-01830: 日期格式图片在转换整个输入字符串之前结束: Solution：如果程序或者数据库报错信息这个的话，一定是其中一个字段或者属性的值出现类似于 2005-10-01 12:01:01.0’ 后面多了一个 .0 这个格式。解决方法就是干掉后面的 .0 参见文章如下： 「如何在properties文件中获取maven的 pom.xml 的键值」 「pom.xml使用多套环境及变量获取」 「使用Eclipse新建一个Maven Project时settings配置的mirror仓库地址无法覆盖默认地址导致打包失败」]]></content>
      <tags>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为何网上垃圾资讯越来越多]]></title>
    <url>%2F2018%2F08%2F03%2F%E4%B8%BA%E4%BD%95%E7%BD%91%E4%B8%8A%E5%9E%83%E5%9C%BE%E8%B5%84%E8%AE%AF%E6%B3%9B%E6%BB%A5%2F</url>
    <content type="text"><![CDATA[某种程度上讲，互联网使得我们小老百姓的权力相比过去有所增加，使得普通人的需求得到关注和满足，而大部分人的天性就是懒于思考的，迷恋于那些非常容易就能获得满足感的事物…… 互联网的快速发展，使得我们每个人都有了发声的渠道，有了表达自己的平台，「再小的个体，也有自己的品牌」。 某种程度上讲，相比过去，我们的权力在变大，我们的需求在被各种公司关注研究，他们做市场调研、做技术积累沉淀、做大数据分析、做人工智能，他们费尽心力努力打造出我们需要的产品，来满足我们的需求。我们似乎真的在网络上得到了「顾客就是上帝」般的高质量服务，我们吃喝玩乐都能轻轻松松的在手机上的几个 APP 里完成。当然，公司设计出这些满足我们需求的产品，就是为了赚钱，赚钱也是现在社会的主旋律，而要想打造出用户喜爱的产品，就一定弄清用户的需求、了解用户的心理。 互联网公司的用户就是普罗大众，要弄懂普通人的需求，得先了解人性。 回想一下，每当我们忍不住刷手机时，到底是在想获得什么？刷微博、刷朋友圈、刷各种圈子、看新闻、读公号文章、小视频，在刷手机的那一刻，仿佛时间过的很充实，我又看到了好多新鲜事、学到了好多知识、还有朋友圈里获得的不真实的优越感或认同感、游戏中得到的成就感，总结起来，其实都是为了获得一种「满足感」。 而我们大部分人天性懒于思考（包括此刻的我，这些文字我写的很慢很艰难），这也导致了我们对很多的东西缺乏辨别能力，很容易被一些标题党或泛滥的爱国主义民族大义等垃圾新闻内容戳中 G 点，这些资讯内容并没有任何价值，甚至很多的新闻内容都是伪造的假新闻，却大量的占用了我们的时间。如今信息技术水平高速发展，这些资讯内容的生产也已经形成的完善的产业化，按照一定的套路拼凑点素材就能快速写出一篇文章，甚至很多新闻稿子是机器流水化生产的按照一定的套路拼凑点素材就能快速写出一篇文章，甚至很多新闻稿子是机器流水化生产的（参见微信公众号「我就 BB 怎么了」的文章说点劲爆的）。 如今，以「头条」系为代表的产品，今日头条、趣头条等各种资讯类 APP，里面充满着标题党、爱国主义、民族大义等垃圾内容，真正有价值的新闻却少之又少，还有像抖音、快手一类的短视频 APP，这些小视频看完了简直让我怀疑人生，爽了一时，却毫无收获。这些科技公司通过技术手段分析用户行为，从而提供智能推送服务，牢牢抓住用户的空闲时间，阻碍用户真正的思考，侵占用户宝贵的时间。 我认为，「独立思考」是我们生而为人的尊严之一，然而如今却有越来越多的人放弃了它，甚至还有些「聪明的家伙」为了私利在助长人们放弃它。]]></content>
      <tags>
        <tag>瞎BB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库锁表怎么办？]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E8%A1%A8%E6%80%8E%E4%B9%88%E5%8A%9E%2F</url>
    <content type="text"><![CDATA[日常开发中出现数据库锁表的情况时，不但影响自己开发，还会影响他人的开发测试，应当立即定位到被锁的表，并执行解锁操作。 Oracle 数据库锁表查询及解锁12345678-- 查询 SQL 如下：select dbaobj.owner, dbaobj.object_name, s.sid, s.serial#, lckobj.locked_mode from v$locked_object lckobj, dba_objects dbaobj, v$session swhere lckobj.object_id = dbaobj.object_id and lckobj.session_id = s.sidorder by s.logon_time;-- 解锁方法：alter system kill session &apos;sid,serial#&apos;; dba_objects 视图：记录数据库中所有对象 v$locked_object 视图 ：记录当前系统中哪些对象正被锁定 v$session 视图：记录所有会话信息 数据库锁分类按照锁的内容上区分：表锁、页锁、行锁 按照锁的性质上区分：共享锁、排他锁 / 独占锁、更新锁 当执行 select 时，加共享锁，当执行 insert，update，delete 等操作时，加排他锁 数据库隔离级别 脏读：对于两个事务T1，T2，T1读取了已经被T2更新但还没有提交的字段，之后，若T2回滚，T1读取到的内容就是临时无效的内容。 不可重复读：对于事务T1，T2，T1需要读取一个字段两次，在第一次和第二次读取之间，T2更新了该字段，导致T1第二次读取到的内容值不同。 幻读： 事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。 幻读与不可重复读之间的区别是幻读强调的是新增或删除,而不可重复读强调的是修改。比如Mary两次查工资，中间有人改过工资，则两次结果不一样，这就是不可重复读。Mary要查工资一千的人数，第一次查到了10个，中间有人增加了一条工资为一千的人，下次查的时候就变成了11个，好像第一次查询的是幻觉一样。 事务的 4 个隔离级别： read uncommitted：可以读取已由其他事务修改但未提交的行； read committed：不能读取已由其他事务修改但未提交的行；其他事务可以在当前事务的各个语句之间更改数据，从而产生不可重复读取和幻读数据； repeatable read：不能读取已由其他事务修改但未提交的行，并且指定，其他任何事务都不能在当前事务完成之前修改当前事务读取的数据；其他事务可以插入与当前事务语句的搜索条件相匹配的新行，如果当前事务随后重复执行该语句，会检索新行，产生幻读； serializable：所有事务只能一个接一个串行执行，不能并发。 Oracle 支持两种隔离级别：read commited、serializable，默认的事务隔离级别是 read commited 乐观锁与悲观锁Java 开发中经常看到乐观锁，那么到底什么是乐观锁，什么是悲观锁呢？ 悲观锁：数据库实现。共享锁、排他锁都属于悲观锁，Java 关键字 synchronized 也属于悲观锁。 乐观锁：自己实现。操作数据时，不加锁，进行更新后，再去判断是否冲突了。举例如下 1231. 查询出商品信息，select (status,version) from t_goods where id=#&#123;id&#125;2. 根据商品信息生成订单3. 修改商品 status 为 2，update t_goods set status=2,version=version+1 where id=#&#123;id&#125; and version=#&#123;version&#125;; 参考链接Oracle 锁表问题处理 数据库隔离级别]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任意进制转换]]></title>
    <url>%2F2018%2F08%2F03%2F%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[最初自学编程时撸过一个 36 进制与 10 进制数值批量互转的小工具，今日再看代码时有了新的思考。 短除法回想在学校学习的进制转换方法，这里我使用短除法实现进制转换功能「建议先掏出小本本理清下短除法的步骤」，废话不多说，直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * @param MValue 存储每个 X 项的系数 * @param M M进制 * @param N N进制 * @return String MValue转换为N进制后的（字符串）数值 */public static String M2N(String MValue, int M, int N) &#123; //M、N的值是否在合理范围内 if (M &gt; 36 || M &lt; 2 || N &gt; 36 || N &lt; 2) &#123; System.out.println("仅支持2到36进制间相互转换"); &#125; //将MValue转为lowerCase,并检查其值是否符合规范 String lowerCaseMValue = MValue.toLowerCase(); if (M &lt;= 10) &#123; for (char c : lowerCaseMValue.toCharArray()) &#123; if (!(c &gt;= '0' &amp;&amp; c &lt; (char)(M + 48))) &#123; System.out.println(MValue + "========不是" + M +"进制的数据"); &#125; &#125; &#125; else &#123; char[] chars = lowerCaseMValue.toCharArray(); for (int i=0; i&lt;chars.length; i++) &#123; char tmp = chars[i]; if (!((tmp &gt;= '0' &amp;&amp; tmp &lt;= '9') || (tmp &gt;= 'a' &amp;&amp; tmp &lt; (char)(M + 87)))) &#123; System.out.println(MValue + "========不是" + M +"进制的数据"); &#125; &#125; &#125; List&lt;Integer&gt; lIntNValue = new ArrayList&lt;&gt;(); List&lt;Integer&gt; lIntMVaule = stringToArrayNumber(lowerCaseMValue); List&lt;Integer&gt; duplicateLIntMValue = lIntMVaule; int yushu = 0; //短除法 while (!allEmpty(lIntMVaule)) &#123; for (int i=0; i&lt;lIntMVaule.size(); i++) &#123; int shang = (yushu * M + lIntMVaule.get(i)) / N; yushu = (yushu * M + lIntMVaule.get(i)) % N; duplicateLIntMValue.set(i, shang); &#125; lIntMVaule = duplicateLIntMValue; lIntNValue.add(yushu); yushu = 0; &#125; Collections.reverse(lIntNValue); return arrayNumberToString(lIntNValue); &#125;/* * 检查整型数组是否全为 0 * */public static boolean allEmpty(List&lt;Integer&gt; lIntMVaule) &#123; for (int i : lIntMVaule) &#123; if (i != 0) &#123; return false; &#125; &#125; return true;&#125;/* * 字符串数字转为整型数组 * */public static List&lt;Integer&gt; stringToArrayNumber(String strNum) &#123; List&lt;Integer&gt; lIntNum = new ArrayList&lt;&gt;(); char[] charsNum = strNum.toCharArray(); for (char c : charsNum) &#123; lIntNum.add(getIntFromStr(String.valueOf(c))); &#125; return lIntNum;&#125;/* * 整型数组转为字符串数字 * */public static String arrayNumberToString(List&lt;Integer&gt; lIntNum) &#123; String strNum = ""; for (int i : lIntNum) &#123; strNum += getStrFromInt(i); &#125; return strNum;&#125;/* * 将字符串类型的单个字符转为整型数字 * */public static int getIntFromStr(String str) &#123; return str.charAt(0) &lt;= '9' &amp;&amp; str.charAt(0) &gt;= '0' ? str.charAt(0) - '0' : str.charAt(0) - 'a' + 10;&#125;/* * 将整型数字转为单个字符的字符串 * */public static String getStrFromInt(int value) &#123; String result = null; if (value&gt;=0 &amp;&amp; value&lt;=9) &#123; result = String.valueOf((char)('0' + value)); &#125; else if (value &gt; 9 &amp;&amp; value &lt;36) &#123; result = String.valueOf((char)('a' + value - 10)); &#125; return result; &#125;public static void main(String[] args) &#123; String result = M2N("123y5abc", 36, 10); System.out.println(result); // 82956480888&#125; 空间换时间的思想基于「空间换时间」的思想，我对上面的代码进行了一番修改，利用 HashMap 来存储字符和十进制数值的映射关系，修改 stringToArrayNumber、arrayNumberToString 这两个方法，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public static final HashMap&lt;Character, Integer&gt; INTMAP = new HashMap&lt;&gt;(36);/* * 使用数组更快更简洁：char CHARMAP = &#123;'0', '1', '2', '3', …… ,'y','z'&#125;; */public static final HashMap&lt;Integer, Character&gt; CHARMAP = new HashMap&lt;&gt;(36); static &#123; INTMAP.put('0', 0); INTMAP.put('1', 1); INTMAP.put('2', 2); INTMAP.put('3', 3); INTMAP.put('4', 4); INTMAP.put('5', 5); INTMAP.put('6', 6); INTMAP.put('7', 7); INTMAP.put('8', 8); INTMAP.put('9', 9); INTMAP.put('a', 10); INTMAP.put('b', 11); INTMAP.put('c', 12); INTMAP.put('d', 13); INTMAP.put('e', 14); INTMAP.put('f', 15); INTMAP.put('g', 16); INTMAP.put('h', 17); INTMAP.put('i', 18); INTMAP.put('j', 19); INTMAP.put('k', 20); INTMAP.put('l', 21); INTMAP.put('m', 22); INTMAP.put('n', 23); INTMAP.put('o', 24); INTMAP.put('p', 25); INTMAP.put('q', 26); INTMAP.put('r', 27); INTMAP.put('s', 28); INTMAP.put('t', 29); INTMAP.put('u', 30); INTMAP.put('v', 31); INTMAP.put('w', 32); INTMAP.put('x', 33); INTMAP.put('y', 34); INTMAP.put('z', 35); CHARMAP.put(0, '0'); CHARMAP.put(1, '1'); CHARMAP.put(2, '2'); CHARMAP.put(3, '3'); CHARMAP.put(4, '4'); CHARMAP.put(5, '5'); CHARMAP.put(6, '6'); CHARMAP.put(7, '7'); CHARMAP.put(8, '8'); CHARMAP.put(9, '9'); CHARMAP.put(10, 'a'); CHARMAP.put(11, 'b'); CHARMAP.put(12, 'c'); CHARMAP.put(13, 'd'); CHARMAP.put(14, 'e'); CHARMAP.put(15, 'f'); CHARMAP.put(16, 'g'); CHARMAP.put(17, 'h'); CHARMAP.put(18, 'i'); CHARMAP.put(19, 'j'); CHARMAP.put(20, 'k'); CHARMAP.put(21, 'l'); CHARMAP.put(22, 'm'); CHARMAP.put(23, 'n'); CHARMAP.put(24, 'o'); CHARMAP.put(25, 'p'); CHARMAP.put(26, 'q'); CHARMAP.put(27, 'r'); CHARMAP.put(28, 's'); CHARMAP.put(29, 't'); CHARMAP.put(30, 'u'); CHARMAP.put(31, 'v'); CHARMAP.put(32, 'w'); CHARMAP.put(33, 'x'); CHARMAP.put(34, 'y'); CHARMAP.put(35, 'z');&#125; public static List&lt;Integer&gt; stringToArrayNumber(String strNum) &#123; List&lt;Integer&gt; listIntNum = new ArrayList&lt;&gt;(); char[] charsNum = strNum.toLowerCase().toCharArray(); for (char c : charsNum) &#123; listIntNum.add(INTMAP.get(c)); &#125; return listIntNum;&#125;public static String arrayNumberToString(List&lt;Integer&gt; lIntNum) &#123; String strNum = ""; for (int i : lIntNum) &#123; strNum += CHARMAP.get(i); &#125; return strNum;&#125; 然后最后的测试结果却很令我失望，先是将 1000 万个十进制数转换成 36 进制数，上面两种方式都用时 8 秒，不分胜负；之后我将 10 亿个十进制数转换成 36 进制，结果第一种方法用时 1073 秒，第二种用时 1235 秒。很是郁闷，看来「空间换时间」只适合用在超复杂计算的时候，上面这种简单的计算并不适用。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密解密技术]]></title>
    <url>%2F2018%2F08%2F03%2F%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[对称加密使用的密钥只有一个，加密解密使用同一密钥。数据发送方将明文与密钥经加密算法处理后发送出去，数据接收方使用密钥及相同算法的逆算法解密密文。常用的对称加密算法： DESDES（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合。DES 使用 56 位密钥，24 小时内即可被破解，但还是可以在某些简单应用中使用 DES 加密算法。注意：DES 密钥的长度必须是 8 的倍数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class DES &#123; // 测试 public static void main(String args[]) &#123; // 待加密内容 String str = "TEST"; // 密码，长度要是8的倍数 String password = "12345678"; byte[] result = DES.encrypt(str.getBytes(), password); System.out.println("加密后：" + new String(result)); //加密后：�b\:p�7L // 直接将如上内容解密 try &#123; byte[] decryResult = DES.decrypt(result, password); System.out.println("解密后：" + new String(decryResult)); //解密后：TEST &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; // key1(SecretKeyFactory)：3132323434373738 // key2(KeyGenerator)：85ABC12F54AB676E // key3(SecretKeySpec)：3132333435363738 printKey(password.getBytes()); &#125; public static byte[] encrypt(byte[] datasource, String password) &#123; try &#123; //密钥 DESKeySpec desKey = new DESKeySpec(password.getBytes()); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES"); SecretKey securekey = keyFactory.generateSecret(desKey); // Cipher对象实际完成加密操作 Cipher cipher = Cipher.getInstance("DES"); SecureRandom random = new SecureRandom(); cipher.init(Cipher.ENCRYPT_MODE, securekey, random); // 正式执行加密操作 return cipher.doFinal(datasource); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; return null; &#125; public static byte[] decrypt(byte[] src, String password) throws Exception &#123; // 创建一个DESKeySpec对象 DESKeySpec desKey = new DESKeySpec(password.getBytes()); // 创建一个密匙工厂 SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES"); // 将DESKeySpec对象转换成SecretKey对象 SecretKey securekey = keyFactory.generateSecret(desKey); // Cipher对象实际完成解密操作 Cipher cipher = Cipher.getInstance("DES"); // DES算法要求有一个可信任的随机数源 SecureRandom random = new SecureRandom(); // 用密匙初始化Cipher对象 cipher.init(Cipher.DECRYPT_MODE, securekey, random); // 真正开始解密操作 return cipher.doFinal(src); &#125; public static void printKey(byte[] keyBytes)&#123; try&#123; //第一种，Factory DESKeySpec keySpec=new DESKeySpec(keyBytes); SecretKeyFactory keyFactory=SecretKeyFactory.getInstance("DES"); SecretKey key1=keyFactory.generateSecret(keySpec); //第二种, Generator KeyGenerator keyGenerator=KeyGenerator.getInstance("DES"); keyGenerator.init(56, new SecureRandom(keyBytes));//key为8个字节，实际用了56位； 后面随机数用key作为种子seed生成 SecretKey key2=keyGenerator.generateKey(); //第三种， SecretKeySpec SecretKey key3=new SecretKeySpec(keyBytes, "DES");//SecretKeySpec类同时实现了Key和KeySpec接口 //打印 System.out.println("key1(SecretKeyFactory)："+byteToHexString(key1.getEncoded())); System.out.println("key2(KeyGenerator)："+byteToHexString(key2.getEncoded())); System.out.println("key3(SecretKeySpec)："+byteToHexString(key3.getEncoded())); &#125;catch(Exception e)&#123; System.out.println(e.toString()); &#125; &#125; public static String byteToHexString(byte[] bytes) &#123; StringBuffer sb = new StringBuffer(bytes.length); String sTemp; for (int i = 0; i &lt; bytes.length; i++) &#123; sTemp = Integer.toHexString(0xFF &amp; bytes[i]); if (sTemp.length() &lt; 2) sb.append(0); sb.append(sTemp.toUpperCase()); &#125; return sb.toString(); &#125; private static byte toByte(char c) &#123; byte b = (byte) "0123456789ABCDEF".indexOf(c); return b; &#125;&#125; AESAES（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高。AES 使用 128、192 或 256 位密钥，代码如下，与 DES 实现类似： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class AES &#123; public static void main(String[] args) &#123; // 待加密内容 String str = "TEST"; // 密码，长度要是8的倍数 String password = "12345678"; byte[] encryptResult = AES.encrypt(str.getBytes(), password); System.out.println("加密后：" + new String(encryptResult)); // 加密后：�[o�g@�煞�kr�� byte[] decryptResult = AES.decrypt(encryptResult, password); System.out.println("解密后：" + new String(decryptResult)); // 解密后：TEST // key1(KeyGenerator)：84AAC12F54AB666ECFC2A83C676908C8 // key2(SecretKey)：3132333435363738 printKey(password.getBytes()); &#125; public static byte[] encrypt(byte[] datasource, String password) &#123; KeyGenerator kgen; try &#123; kgen = KeyGenerator.getInstance("AES"); kgen.init(128, new SecureRandom(password.getBytes())); SecretKey secretKey = kgen.generateKey(); byte[] enCodeFormat = secretKey.getEncoded(); // 转换为AES专用密钥 SecretKeySpec key = new SecretKeySpec(enCodeFormat, "AES"); // 创建密码器 Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.ENCRYPT_MODE, key); return cipher.doFinal(datasource); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static byte[] decrypt(byte[] src, String password) &#123; KeyGenerator kgen; try &#123; kgen = KeyGenerator.getInstance("AES"); kgen.init(128, new SecureRandom(password.getBytes())); SecretKey secretKey = kgen.generateKey(); byte[] enCodeFormat = secretKey.getEncoded(); // 转换为AES专用密钥 SecretKeySpec key = new SecretKeySpec(enCodeFormat, "AES"); // 创建密码器 Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.DECRYPT_MODE, key); return cipher.doFinal(src); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static String byteToHexString(byte[] bytes) &#123; StringBuffer sb = new StringBuffer(bytes.length); String sTemp; for (int i = 0; i &lt; bytes.length; i++) &#123; sTemp = Integer.toHexString(0xFF &amp; bytes[i]); if (sTemp.length() &lt; 2) sb.append(0); sb.append(sTemp.toUpperCase()); &#125; return sb.toString(); &#125; public static void printKey(byte[] keyBytes)&#123; try&#123; // KeyGenerator KeyGenerator keyGenerator=KeyGenerator.getInstance("AES"); keyGenerator.init(128, new SecureRandom(keyBytes));//key为128, 192 or 256 SecretKey key2=keyGenerator.generateKey(); // SecretKeySpec SecretKey key3=new SecretKeySpec(keyBytes, "AES");//SecretKeySpec类同时实现了Key和KeySpec接口 //打印 System.out.println("key1(KeyGenerator)："+byteToHexString(key2.getEncoded())); System.out.println("key2(SecretKey)："+byteToHexString(key3.getEncoded())); &#125;catch(Exception e)&#123; System.out.println(e.toString()); &#125; &#125;&#125; PS： ​ Should I use KeyGenerator or SecretKeyFactory? ​ 产生密钥的四个类的区别： KeyGenerator， KeyPairGenerator，KeyFactory，SecretKeyFactory 非对称加密使用一对密钥「公钥、私钥」。主要算法有，RSA、ECC（椭圆曲线加密算法）， 两种用法： 用于加密：公钥加密，私钥解密，这样只有我自己知道别人发送给我的消息； 用于签名：私钥加密，公钥解密，这样只有我自己可以发布这个签名，私钥负责签名，公钥负责验证。 关于这些加密算法的实现其实都大同小异，网上资料也很多，就不再发出来了。 Hash（散列）算法引用百度百科介绍，「就是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射 」。常见的有 MD5 和 SHA 算法。 输出散列值长度（bits） 最大输入消息长度（bits） MD5（消息摘要算法） 128 无限 SHA1 160 2^64 - 1 SHA2(SHA256) 256 2^128 - 1 SHA3(SHA256、SHA512) 256、512 无限 使用 JDK 提供的 MessageDigest 对象获取信息摘要，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139public class Test &#123; protected static char hexDigits[] = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' &#125;; public static MessageDigest messagedigest = null; /** * 对一个文件获取md5值 */ public static String getMD5(File file) throws IOException, NoSuchAlgorithmException &#123; messagedigest = MessageDigest.getInstance("MD5"); FileInputStream in = new FileInputStream(file); FileChannel ch = in.getChannel(); MappedByteBuffer byteBuffer = ch.map(FileChannel.MapMode.READ_ONLY, 0, file.length()); messagedigest.update(byteBuffer); return bufferToHex(messagedigest.digest()); &#125; /*** * 获取文件SHA1码 */ public static String getSha1(File file) throws OutOfMemoryError, IOException, NoSuchAlgorithmException &#123; messagedigest = MessageDigest.getInstance("SHA-1"); FileInputStream in = new FileInputStream(file); FileChannel ch = in.getChannel(); MappedByteBuffer byteBuffer = ch.map(FileChannel.MapMode.READ_ONLY, 0, file.length()); messagedigest.update(byteBuffer); return bufferToHex(messagedigest.digest()); &#125; /** * 获取文件SHA256码 */ public static String getSha256(File file) throws OutOfMemoryError, IOException, NoSuchAlgorithmException &#123; messagedigest = MessageDigest.getInstance("SHA-256"); FileInputStream in = new FileInputStream(file); FileChannel ch = in.getChannel(); MappedByteBuffer byteBuffer = ch.map(FileChannel.MapMode.READ_ONLY, 0, file.length()); messagedigest.update(byteBuffer); return bufferToHex(messagedigest.digest()); &#125; /** * 获取文件SHA512码 */ public static String getSha512(File file) throws OutOfMemoryError, IOException, NoSuchAlgorithmException &#123; messagedigest = MessageDigest.getInstance("SHA-512"); FileInputStream in = new FileInputStream(file); FileChannel ch = in.getChannel(); MappedByteBuffer byteBuffer = ch.map(FileChannel.MapMode.READ_ONLY, 0, file.length()); messagedigest.update(byteBuffer); return bufferToHex(messagedigest.digest()); &#125; public static String getMD5String(String s) &#123; return getMD5String(s.getBytes()); &#125; public static String getMD5String(byte[] bytes) &#123; messagedigest.update(bytes); return bufferToHex(messagedigest.digest()); &#125; /** * @Description 计算二进制数据 * @return String */ private static String bufferToHex(byte bytes[]) &#123; return bufferToHex(bytes, 0, bytes.length); &#125; private static String bufferToHex(byte bytes[], int m, int n) &#123; StringBuffer stringbuffer = new StringBuffer(2 * n); int k = m + n; for (int l = m; l &lt; k; l++) &#123; appendHexPair(bytes[l], stringbuffer); &#125; return stringbuffer.toString(); &#125; private static void appendHexPair(byte bt, StringBuffer stringbuffer) &#123; char c0 = hexDigits[(bt &amp; 0xf0) &gt;&gt; 4]; char c1 = hexDigits[bt &amp; 0xf]; stringbuffer.append(c0); stringbuffer.append(c1); &#125; public static void main(String[] args) throws NoSuchAlgorithmException, IOException &#123; File file = new File("D://BaiduNetdiskDownload//Yellowstone.S01E04.720p.FIX字幕侠.mp4"); System.out.println(getMD5(file)); System.out.println(getSha1(file)); System.out.println(getSha256(file)); System.out.println(getSha512(file)); // 77039e4c75e6b5d743fd914e76ee281c List&lt;Long&gt; l1 = new ArrayList&lt;&gt;(1000); // 1247f4d02639e9714f500d4110075f70e5270dbf List&lt;Long&gt; l2 = new ArrayList&lt;&gt;(1000); // 5bb6a5b692d90514fa8df7d5a43f3bfaa3f9d15e191f6347f49bccb395f36ea0 List&lt;Long&gt; l3 = new ArrayList&lt;&gt;(1000); // 4bd6b47d8df7041cd866948a8e2df7d5a87e318f0a5e23ecb91a74fcf55c768d48b743490f89a09cc124b6e07fbae4d791a361f902a0119886a80c7b3d878a64 List&lt;Long&gt; l4 = new ArrayList&lt;&gt;(1000); for (int i = 0; i &lt; 100; i++) &#123; long start1 = System.currentTimeMillis(); getMD5(file); long end1 = System.currentTimeMillis(); l1.add(end1 - start1); long start2 = System.currentTimeMillis(); getSha1(file); long end2 = System.currentTimeMillis(); l2.add(end2 - start2); long start3 = System.currentTimeMillis(); getSha256(file); long end3 = System.currentTimeMillis(); l3.add(end3 - start3); long start4 = System.currentTimeMillis(); getSha512(file); long end4 = System.currentTimeMillis(); l4.add(end4 - start4); &#125; long sum1 = 0; long sum2 = 0; long sum3 = 0; long sum4 = 0; for (Long l : l1) &#123; sum1 += l; &#125; for (Long l : l2) &#123; sum2 += l; &#125; for (Long l : l3) &#123; sum3 += l; &#125; for (Long l : l4) &#123; sum4 += l; &#125; System.out.println(sum1/1000 + " : " + sum2/1000 + " : " + sum3/1000 + " : " + sum4/1000);// 233 : 330 : 493 : 355 &#125;&#125; 测试结果很意外，SHA512 的速度要比 SHA256 快不少，后来 Google 了下，原来是在 64 位 CPU 上 SHA512 比 SHA256 快，而在 32 位 CPU 上运算则是 SHA256 更快。 加盐「在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。」采用的加密方式为md5(md5(password) + salt) ， 其实，以随机字符串对密码加盐仅仅是增加破解密码的难度，增加攻击者的成本。 数字证书有了上面的概念，数字签名、数字证书就很好理解了。 数字签名：信件通过散列函数生成一段定长的信件摘要（即数字指纹），然后通过「非对称加密」私钥对信件摘要加密得到数字签名。那么其他人如何验证数字签名呢？通过公钥对数字签名解密得到摘要文件 digest1，然后对信件使用相同的散列函数得到 digest2，如果 digest1 和 digest2 一致，就说明信件未经篡改。 那么，问题来了，服务端如何将公钥发给客户呢？客户端如何确保该公钥是真实的服务端的公钥而不是某个中间人的公钥（因为每个人都可以自己生成一对公私钥）呢？于是，确保公钥确实是这个证书所有者的数字证书出现了。 数字证书如何确保公钥确实是这个证书所有者的呢？ 数字证书（第三方认证机构 CA 认证公钥）：数字证书包括以下几部分内容： 证书的发布机构及有效期 公钥及证书所有者 签名所使用的算法 指纹及指纹的算法 CA 使用自己的私钥对数字证书加密得到加密后的数字证书，然后服务端发送信件时不光加上自己的数字签名，还会加上 CA 认证的数字证书，而客户端浏览器里已经内置了 CA 的公钥，客户端收到带有数字证书的信件后对数字证书解密即可得到服务端的公钥信息等，然后即可通过服务端的公钥验证该信息。 由于非对称加密很费时，所以实际生产中一般使用非对称加密传输对称加密的密钥，然后服务端与客户端对称加密通信，既保证了安全，又提高了效率。 查看计算机或浏览器本地证书的方法网上很多，运行 certmgr.msc ，下图是我 PC 里本地证书的截图： BASE 64 编码为什么需要 BASE 64 编码？ 计算机中任何数据都是按 ascii 码存储的，而 ascii 码的 128～255 之间的值是不可见字符，而网络中不同的设备（路由器、交换机）对字符处理方式有些不同，这样不可见字符可能被处理错误，所以就把数据先做一个 BASE 64 编码统统变成可见字符，这样出错的可能性就大降低了。而且有些文本协议不支持不可见字符的传递，只能转换成可见字符来传递信息 。 Java 8的java.util套件中，新增了Base64的类别，可以用来处理Base64的编码与解码，用法如下： 1234567891011public class Test &#123; public static void main(String[] args) &#123; Base64.Encoder encoder = Base64.getEncoder(); Base64.Decoder decoder = Base64.getDecoder(); String str = &quot;BASE64编码&quot;; String encodeStr = encoder.encodeToString(str.getBytes()); System.out.println(encodeStr); byte[] decodeStr = decoder.decode(encodeStr); System.out.println(decodeStr.toString()); &#125;&#125; Java 项目中的加密解密 前端 JS 加解密（crypto-js） 后端 Java 加解密]]></content>
      <tags>
        <tag>Java</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取properites配置文件信息]]></title>
    <url>%2F2018%2F08%2F03%2F%E8%8E%B7%E5%8F%96properites%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[最近在项目中看到别人使用 ResourceBundle 获取 properites 配置文件信息，感觉挺方便的，学习记录于此。 通过 getResourceAsStream 方式获取getResourceAsStream 这个函数寻找文件的起点是 JAVA 项目编译之后的根目录 。 123456789101112131415161718public class ConfigReader &#123; public static String getProperty(final String propertyName) &#123; return ConfigReader.reader.properties.getProperty(propertyName); &#125; private static final Properties properties = new Properties(); public static final ConfigReader reader = new ConfigReader(); private ConfigReader() &#123; try &#123; //InputStream in = this.class.getClassLoader().getResourceAsStream(&quot;/config.properties&quot;); InputStream in = this.class.getClassLoader().getResourceAsStream(&quot;config.properties&quot;); this.properties.load(in); in.close(); &#125; catch (IOException e) &#123; logger.error(e); &#125; &#125;&#125; 参考链接：（转）java getResourceAsStream的使用方法 通过 ResourceBundle 方式获取只需要下面两行代码就可以搞定： ResourceBundle bundle = ResourceBundle.getBundle(file); String value = bundle.getString(key); 网上说法，「ResourceBundle类通常是用于针对不同的语言来使用的属性文件。根据当前系统的国别语言信息（也可以程序指定），然后获取相应的properties文件的内容」。 我的理解是：需要程序动态获取 .properties 配置文件时使用 ResourceBundle 更加方便，但如果是获取静态的全局配置文件使用 getResourceAsStream 就好，加载一次，就存储在配置 Java 类里]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于写博客]]></title>
    <url>%2F2018%2F08%2F03%2F%E5%85%B3%E4%BA%8E%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[3 W 法是个分析问题的好方法，为了让自己更好的将「写博客」这件小事坚持下去， 尝试用 3 W 法对「怎样写好博客」这个问题作出回答，记录于此。 为什么写博客「记录世界记录你」，作为自己日常工作生活的一种记录方式。 本来过去的我是一个非常活在未来的人，不喜欢回忆过去，也不喜欢拍照记录那些当下的幸福瞬间，总觉得更美好的东西永远在未来。可能现在年龄大了，也时常回忆起过去的事情，而且现在的我觉得，时间真的是一种美妙的东西（看完《三体》影响我很多，使我睁眼看到了时间的柔美）。有着过去珍贵的记忆、对当下生活的珍惜和对未来的美好想象，这才是一种更加丰满健全的生活态度。而人的记忆却并不那么可靠，所以从此刻开始，每当有些值得记录的事情或自己的所思所想，我都会记录于此。 「个人表达」能力在当今社会变得越来越为重要，而这恰恰是我非常欠缺的。自己是个相对内向（不高兴时一个人静静呆着就能积攒正能量开始新的一天）的人，没有才艺，不善社交，语言表达能力弱，所以「写作」应该就是一种最适合自己的表达方式了 。 「职业素养」，作为一个程序员，你怎么能没有自己的博客呢？写博客对码农的好处与必要性，网上已经有很多讨论了：加强记忆、加深对技术点的理解、倒闭输出成长大牛。 写什么内容首先当然就是技术相关的文章，写一些自己学习技术的过程和方法，总结工作学习中踩过的那些坑。 然后就是写一些自己日常的小思考。 准备怎么写技术类文章的写作，充分发挥程序员 CTRL + C 和 CTRL + V 的特长，记录学习过程（环境搭建、学习笔记）和踩坑经验（日常问题点及网上查找到的解决方法）。 个人小杂文的写作，初期当然就是瞎写啦，想到什么写什么。 关于坚持年龄越大就越会懂得坚持的力量，如何将写博客这件小事坚持下去呢？ 降低期望，不要太过在意自己写的文章烂，写的烂总比不写要强吧。 与人分享自己的文章，这样是对自己的一个激励反馈，也能发现自己文章的不足之处和提高的方向。 学习相关写作技巧，提高文章质量。 傻傻等待，傻傻等春暖花开。]]></content>
      <tags>
        <tag>瞎BB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建自己的工具箱]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%B7%A5%E5%85%B7%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[「工欲善其事，必先利其器。」 有幸看到一篇名为《给年轻程序员的几条建议》的文章，感觉很受益，并开始思考如何打造自己的工具箱。 过去我总认为工具不重要，需要使用时拿来用即可，使用任何工具都无所谓，只要最终能达到我的目的就可以了，现在才领悟过来，熟练使用一款工具会大大提升自己的工作效率。 编辑器：「notepad++」，因为开源，因为免费，因为小巧轻便。 知识库管理：目前使用「有道云笔记」做信息采集和笔记，使用 「Typora 」工具写博客文章。 文件搜索：「everything」，小巧高效的文件搜索工具。 密码管理器：「keepass」，我觉得每个人都应该了解并使用一款密码管理器，解决经常忘记密码的烦恼。 虚拟机软件：「VMware」，Linux 是必须要学要使用的，当然是装虚拟机啦。 Windows 系统备份垃圾清理工具：「Dism++」，功能强大，绿色干净。 Java 反编译工具：「jd-gui」，小巧快速。当然也可以使用 Eclipse 插件 JD-Eclipse 。 文件比较工具：「diffmerge」。 远程桌面工具：「TeamViewer」，免费（个人版）好用。 快捷键是个好东西，应当尽量使用熟悉起来，可以大大改善软件的使用体验，提高生产效率。]]></content>
      <tags>
        <tag>瞎BB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Server 转 Oracle]]></title>
    <url>%2F2018%2F08%2F03%2FSQLServer%20%E8%BD%AC%20Oracle%2F</url>
    <content type="text"><![CDATA[工作中碰到需要把 SQL Server 的数据迁移到 Oracle 的情况，踩坑总结。 一. 使用 SQL Server 本身提供的「导入导出」工具，将 SQL Server 数据转到 Oracle 中环境：64 位 SQL Server、Oracle、「导入导出」工具。 起初使用 32 位 Oracle 数据库，一直导入失败，后换用 64 位 Oracle 数据库后正常。注意：「导入导出」工具也要使用 64 位，否则也会出错。 参考文章：&lt;a href=”https://blog.csdn.net/x541211190/article/details/72842149 将SQLServer表直接导入Oracle数据库（图文教程） 注意： 默认转换有些表和字段的映射会不太准确，一定要一一确认； SQL Server 导入 Oracle 的表和字段有区分大小写； 表的主键、索引等信息都没有自动导入 Oracle 中去。 二. 将转到 Oracle 中的所有表和字段全转为大写由于 Oracle 中的表和字段都是有区分大小写的，而 Oracle 执行 SQL 语句时会自动全部转为大写，所以这里需要将 Oracle 中的表和字段全转为大写，使用如下存储过程批量修改： 123456789101112131415161718192021-- 修改当前用户的所有表所有字段为大写begin DBMS_OUTPUT.ENABLE(1000000); for t in (select table_name tn from user_tables) loop begin for c in (select column_name cn from user_tab_columns where table_name=t.tn) loop begin execute immediate &apos;alter table &apos;||t.tn||&apos; rename column &quot;&apos;||c.cn||&apos;&quot; to &apos;||upper(c.cn); exception when others then dbms_output.put_line(t.tn||&apos;.&apos;||c.cn||&apos;已经存在&apos;); end; end loop; execute immediate &apos;alter table &quot;&apos;||t.tn||&apos;&quot; rename to &apos;||upper(t.tn); exception when others then dbms_output.put_line(t.tn||&apos;已存在&apos;); end; end loop; end; 由于 SQL server 在录入时对录入内容区分大小写，但在查询时对代码不区分大小写，所以可能会出现同样的查询条件，原本在 SQL server 中正常查出结果的换到 Oracle 中却会查询错误的情况。 三. 为 Oracle 中的表手动建立主键、索引等SQL server 和 Oracle 数据类型对应： SQL Server 数据类型 Oracle 数据类型 char(1-2000) CHAR(1-2000) char(2001-4000) VARCHAR2(2001-4000) nvarchar(1-1000) VARCHAR2(1-2000) varchar(1-4000) VARCHAR2(1-4000) date、datetime、smalldatetime DATE dateadd(year,1,a.EffDate) add_months(a.EffDate,12) int NUMBER(10,0) float FLOAT 参考链接：博客园：Oracle和sqlserver数据类型对应 SQL server 和 Oracle 常用函数对应： SQL Server 函数 Oracle 函数 convert(char(20),getdate(),120) to_char(sysdate, ‘yyyy-mm-dd hh24:mi:ss’) CONVERT(varchar(100), GETDATE(), 23) to_char(sysdate, ‘yyyy-mm-dd’) CONVERT(varchar(100), GETDATE(), 24) to_char(sysdate, ‘hh24:mi:ss’) datediff(YEAR,EffDate,getdate()) (extract(year from sysdate)-extract(year from EffDate)) dateadd(year,1,a.EffDate) add_months(a.EffDate,12) isnull(n.cnt, 0) nvl(n.cnt, 0) cast(-1.002 as int) trunc(-1.002) charindex(‘s’,’sdsq’,2) instr(‘sdsq’,’s’,2) substring(‘abcdefg’,2,3) substr(‘abcdefg’,2,3) SQL Server 相关知识点：数据库还原失败「.bak 文件」： ​ 勾选 – 覆盖现有数据库 ​ 取消勾选 – 还原前进行结尾日志备份 ​ 参考文章：SQLserver 备份和还原 失败 SSMS 无法执行大小超过 100M 的 sql 文件： ​ 在 cmd 窗口使用 osql -E -i input_file 命令执行 .sql 文件 ​ 参考文章：sql server 执行上100mb sql sql sql server 无法执行脚本 没有足够的内存继续执行 Oracle 相关知识点：Oracle 数据库创建新用户并授予 DBA 权限： ​ create user abc identified by 123456; ​ grant connect,resource,dba to abc; 为什么 varchar2 很少用： ​ 网上查来的答案：「The NVARCHAR2 is a Unicode-only datatype. Note also that some features won’t work with NVARCHAR2 」，参考链接：Difference between VARCHAR2(10 CHAR) and NVARCHAR2(10) ​ 查看数据库字符集：SELECT * FROM NLS_DATABASE_PARAMETERS; Oracle Date Timestamp 类型区别： Oracle 毫秒的存储必须字段类型为 timestamp(6) – 数字表示存储的毫秒位数 select to_char(systimestamp,&#39;yyyy-mm-dd hh24:mi:ss.ff6&#39;) from dual; -- 2018-07-21 16:40:53.829000]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring]]></title>
    <url>%2F2018%2F08%2F03%2FSpring%2F</url>
    <content type="text"><![CDATA[Spring 优点 方便解耦，简化开发：将所有对象创建和依赖关系维护交给 Spring 管理； AOP 编程的支持； 声明式事务的支持； 方便程序的测试：通过注解方便的测试 Spring 程序； 方便集成各种优秀框架，Struts、Hibernate、MyBatis、Quartz 等。 IOC 与 DIIOC 控制反转，是指对象实例化权利由 spring 容器来管理 ； DI 依赖注入，在 spring 创建对象的过程中，对象所依赖的属性通过配置注入对象中。 Spring 在 web 开发中应用 导入 spring-web-4.2.4.RELEASE.jar 包; 在 web.xml 文件中配置 listener：&lt;listener&gt;&lt;listener-class&gt;org.springframework.web.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;，这个 ContextLoaderListener 实现了 ServletContextLister，当服务器启动时，将 ApplicationContext(其实是它的实现类 WebApplicationContext)对象存入到 ServletContext 中; 在 web.xml 文件中配置 applicationContext.xml 文件的位置 ，&lt;context_param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param_name&gt;&lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context_parm&gt;。 Spring 事务管理Spring 事务管理主要提供三个接口来完成： org.springframework.transaction.PlatformTransactionManager ​ DataSourceTransactionManger 主要针对于 JdbcTemplate、MyBatis 开发； ​ HibernateTransactionManasger 主要针对于 Hibernate 开发； ​ JpaTransactionManager 主要针对于 JPA 开发。 TransactionDefinition TransactionStatus 声明式事务管理]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ResultSet 使用总结]]></title>
    <url>%2F2018%2F08%2F03%2FResultSet%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[唯有疼痛，方可刻骨铭心。 通过 ResultSet.getString() 方法取一个 Oracle 数据库中的 Date 类型的字段，取出的值变成了 2018-7-2 12.12.12.0，着实神奇。 1234567891011121314151617181920212223Statement stm = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);ResultSet rs = stm.executeQuery(sql);if (rs.next()) &#123; System.out.println(rs.getString(2)); System.out.println(rs.getDate(2)); System.out.println(rs.getTime(2));&#125; Statement stm2 = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);ResultSet rs2 = stm2.executeQuery(sql);if (rs2.next()) &#123; System.out.println(rs2.getString(2)); System.out.println(rs2.getDate(2)); System.out.println(rs2.getTime(2));&#125;//运行结果如下：2018-7-2 15.34.48.02018-07-0215:34:482018-07-02 15:34:48.02018-07-0215:34:48 ResultSet 的 Type 属性：Connection 的 Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException 方法; 参数 resultSetType: ​ ResultSet.TYPE_FORWORD_ONLY 结果集的游标只能向下滚动。 ​ ResultSet.TYPE_SCROLL_INSENSITIVE 结果集的游标可以上下移动，当数据库变化时，当前结果集不变。 ​ ResultSet.TYPE_SCROLL_SENSITIVE 返回可滚动的结果集，当数据库变化时，当前结果集同步改变。 参数 resultSetConcurrency： ​ ResultSet.CONCUR_READ_ONLY 不能用结果集更新数据库中的表 。 ​ ResultSet.CONCUR_UPDATETABLE 能用结果集更新数据库中的表。 参考链接：ResultSet 的Type属性 TYPE_FORWARD_ONLY 创建 Statement 的三种类型：最基本的 Statement st = conn.CreateStatement() ​ 只能使用 next() 方法，逐个的读取数据。 可滚动的、可更新的 ResultSet ​ Statement st = conn.createStatement(int resultSetType, int resultSetConcurrency) ； ​ ResultSet 有 insertRow()、deleteRow()、updateRow() 等各种方法，见 ResultSet 源码。 可保持的ResultSet ​ Statement st = conn.createStatement(int resultsetscrollable,int resultsetupdateable,int resultsetSetHoldability) ，见 Connection 类源码； 疼痛总结： 理论与实践并重。最初自学编程时总是看得多，动手少，最后学完很容易忘记，上手写代码脑中一片空白，充满挫败感；后来工作繁忙，便放松了基本理论的学习，又导致在项目开发中踩了不少深坑（其实都是些很基础的小问题），耽误了时间。 注重开发规范。有些同事（包括自己有时也是这样）写起代码来一把梭，全然不顾读代码人的感受，再加上项目都是多人协作，事先没个规范最后出问题 debug 时就是个深坑，出现各种问题，修复这个 bug 时又会出现另一个 bug，掉入不断修复 bug 的漩涡之中。 bug 最终还是要自己修复的。求助他人只是起到点拨作用，开阔自己解决问题的思路，最终问题还是得自己解决的。 源码里面找方法。]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 导出 sql 文件乱码]]></title>
    <url>%2F2018%2F08%2F03%2FOracle%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A1%A8%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[何为良好生活？陈嘉映说「行之于途而应于心」；路遥也曾说过「只有在无比沉重的劳动中,人才会活得更为充实」。在这个价值流失的年代如何自处，我想很简单，撸起袖子加油干，做好眼前事就行了，在做事行路的过程中自然就会找寻到意义，意义不是空想出来的，而是在实践中产生的。 这篇文章简单记录 Oracle 导出表结构表数据的关键点，使用常用的 plsql 工具。 Export Tables 的三种导出方式使用 plsql 工具导出表结构表数据其实很简单方便，打开 plsql 工具，选择 Tools 菜单栏下面的 Expor Tables 即可。点开你会发现如下界面： 第一种 Oracle Export 是导出为 .dmp 的文件格式，.dmp文件是二进制的，可以跨平台，还能包含权限，效率也很不错，用得最广 。 第二种 SQL Insert 是导出为.sql文件的，可用文本编辑器查看，通用性比较好，但效率不如第一种，适合小数据量导入导出。尤其注意的是表中不能有大字段（blob,clob,long），如果有，会提示不能导出(提示如下： table contains one or more LONG columns cannot export in sql format,user Pl/sql developer format instead)。 第三种是导出为.pde格式的，.pde为Pl/sql developer自有的文件格式，只能用Pl/sql developer自己导入导出，不能用编辑器查看。 需要注意的是： 就算你选择第一种 Oracle Export 方式导出为 .sql 文件，也是可以的，但是最终导出的 sql 文件打开会有乱码，我一开始并不清楚这三种导出方式的区别，使用第一种方式导出为 .sql 文件一直是乱码，浪费了不少时间。 导出的 SQL 文件中文乱码关于导出乱码的问题，网上有很多教程，但都是抄来抄去也写的不清晰，这里基于自己实际解决乱码问题的经验简单记录下： 问题的关键就在于 server、client 端的编码要一致， 将 client 端的编码方式修改为和 server 端一致即可。 Oracle 字符集： ORACLE的字符集名字由三部分组成：NLS_LANG=\_\.\ 比如常见的 nls_lang=AMERICAN_AMERICA.UTF8 ； nls_lang=SIMPLIFIED CHINESE_AMERICA.UTF8 查看 Server 字符集环境： 123456SELECT * FROM NLS_DATABASE_PARAMETERS;-- 我的查询结果如下：PARAMETER VALUENLS_LANGUAGE AMERICANNLS_TERRITORY AMERICANLS_CHARACTERSET AL32UTF8 数据库可用字符集参数设置： SELECT * FROM V$NLS_VALID_VALUES 注意：SELECT * FROM NLS_INSTANCE_PARAMETERS 是表示实例的字符集环境，而不是客户端。 查看 Client 字符集环境： SELECT USERENV(&#39;language&#39;) FROM DUAL; 修改 Client 字符集： 我使用的开发环境是 Windows，所以只写在 Windows 下的操作方法：修改注册表键值永久设置，HKEY_LOCAL_MACHINE/SOFTWARE/ORACLE/KEY_XXXX_home1/NLS_LANG，将值修改为 AMERICAN_AMERICA.AL32UTF8 后导出的 sql 文件编码正确，显示正常。 参考文章：Oracle 字符集基础知识]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
